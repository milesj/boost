declare module 'boost' {
  declare export type EventArguments = *[];

  declare export type EventListener = (...args: EventArguments) => void;

  declare export type EventNextHandler = (index: number, ...args: EventArguments) => void;

  declare export type PackageConfig = {
    name: string,
    version: string,
  };

  declare export type Result = *;

  declare export type ResultPromise = Promise<Result>;

  declare export type Status = 'pending' | 'running' | 'skipped' | 'passed' | 'failed';

  declare export type TaskCallback<Tx> = (value: Result, context: Tx) => Result | ResultPromise;

  declare export type TasksLoader<Tx> = () => Task<*, Tx>[];

  declare export type ToolConfig = {
    debug: boolean,
    extends: string | string[],
    silent: boolean,
    [key: string]: *,
  };

  declare export type ToolOptions = {
    appName: string,
    pluginName: string,
    reporter: Reporter<*>,
    root: string,
    scoped: boolean,
    title: string,
  };

  declare class ConfigLoader {
    config: ToolConfig;
    options: ToolOptions;
    package: PackageConfig;
    parsedFiles: { [key: string]: boolean };

    constructor(options: ToolOptions): this;
    loadConfig(): ToolConfig;
    loadPackageJSON(): PackageConfig;
    parseAndExtend(fileOrConfig: string | Object): Object;
    parseFile(filePath: string, options?: Object): Object;
    resolveExtendPaths(extendPaths: string | string[], baseDir?: string): string[];
    resolveModuleConfigPath(appName: string, moduleName: string, preset?: boolean, ext?: string): string;
  }

  declare class PluginLoader<Tp: Plugin<*>> {
    options: ToolOptions;
    plugins: Tp[];

    constructor(options: ToolOptions): this;
    importPlugin(name: string, options?: Object): Tp;
    importPluginFromOptions(baseOptions: Object): Tp;
    loadPlugins(plugins: (string | Tp)[]): Tp[];
    sortPlugins(): this;
  }

  declare export class Plugin<To: Object> {
    moduleName: string;
    name: string;
    options: To;
    priority: number;
    tool: Tool<*, *>;

    constructor(options?: To): this;
    bootstrap(): void;
  }

  declare export type ReporterOptions = {
    clearOutput: boolean,
    refreshRate: number,
    silent: boolean,
  };

  declare export class Reporter<Tx: Object> {
    instance: number;
    hasFailed: boolean;
    loader: ?TasksLoader<Tx>;
    options: ReporterOptions;

    constructor(options?: Object): this;
    indent(length: number): string;
    render(tasks: Task<*, Tx>[]): string;
    renderTask(task: Task<*, Tx>, level?: number, suffix?: string): string[];
    renderStatus(task: Task<*, Tx>): string;
    start(loader: TasksLoader<Tx>): void;
    stop(): void;
    update(stop?: boolean): false;
  }

  declare export default class Console<Tr: Reporter<*>> {
    debugs: string[];
    debugGroups: string[];
    errors: string[];
    logs: string[];
    reporter: Tr;

    constructor(reporter: Tr): this;
    debug(message: string): void;
    displayOutput(): void;
    displayError(error?: ?Error): void;
    error(message: string): void;
    log(message: string): void;
    start(loader: TasksLoader<*>): void;
    startDebugGroup(group: string): void;
    stop(): void;
    stopDebugGroup(): void;
    update(): void;
  }

  declare export class Event {
    name: string;
    next: ?EventNextHandler;
    stopped: boolean;
    time: number;
    value: *;

    constructor(name: string, value?: *): this;
    stop(): void;
  }

  declare export class Emitter {
    listeners: { [eventName: string]: Set<EventListener> };

    emit(eventName: string, initialValue: Result, args?: EventArguments): Event;
    emitCascade(eventName: string, initialValue: Result, args?: EventArguments): Event;
    getEventNames(): string[];
    getListeners(eventName: string): Set<EventListener>;
    off(eventName: string, listener: EventListener): this;
    on(eventName: string, listener: EventListener): this;
  }

  declare export class Tool<Tp: Plugin<*>, Tr: Reporter<*>> extends Emitter {
    config: ToolConfig;
    configLoader: ConfigLoader;
    console: Console<Tr>;
    initialized: boolean;
    options: ToolOptions;
    package: PackageConfig;
    pluginLoader: PluginLoader<Tp>;
    plugins: Tp[];

    constructor(options: Object): this;
    debug(message: string): this;
    getPlugin(name: string): Tp;
    initialize(): this;
    invariant(condition: boolean, message: string, pass: string, fail: string): this;
    loadConfig(): this;
    log(message: string): this;
    logError(message: string): this;
    loadPlugins(): this;
  }

  declare export class Task<Tc: Object, Tx: Object> {
    action: ?TaskCallback<Tx>;
    config: Tc;
    context: Tx;
    frame: number;
    title: string;
    status: Status;
    subroutines: Task<*, Tx>[];
    subtasks: Task<*, Tx>[];

    constructor(title: string, action?: ?TaskCallback<Tx>, defaultConfig?: Tc): this;
    hasFailed(): boolean;
    hasPassed(): boolean;
    isPending(): boolean;
    isRunning(): boolean;
    isSkipped(): boolean;
    run(value: Result, context: Tx): ResultPromise;
    skip(condition?: boolean): this;
    wrap(value: *): ResultPromise;
  }

  declare export class Routine<Tc: Object, Tx: Object> extends Task<Tc, Tx> {
    key: string;
    tool: Tool<*, Reporter<Tx>>;

    constructor(key: string, title: string, defaultConfig?: Tc): this;
    bootstrap(): void;
    configure(parent: Routine<*, Tx>): this;
    execute(value: Result, context: Tx): ResultPromise;
    executeCommand(command: string, args: string[], options?: Object): ResultPromise;
    executeTask(value: Result, task: Task<*, Tx>): ResultPromise;
    parallelizeSubroutines(value: Result): ResultPromise;
    parallelizeTasks(value: Result): ResultPromise;
    pipe(...routines: Routine<*, Tx>[]): this;
    serialize(
      initialValue: Result,
      items: *[],
      accumulator:(value: Result, item: *) => ResultPromise,
    ): ResultPromise;
    serializeSubroutines(value: Result): ResultPromise;
    serializeTasks(value: Result): ResultPromise;
    task<C>(title: string, action: TaskCallback<Tx>, config?: C): Task<C, Tx>;
  }

  declare export class Pipeline<Tx: Object, Tp: Plugin<*>> extends Routine<ToolConfig, Tx> {
    constructor(tool: Tool<Tp, Reporter<Tx>>): this;
    loadTasks(): Task<*, Tx>[];
  }
}
