declare module 'boost' {
  import type { Blueprint } from 'optimal';

  declare export type ConfigStruct = { [key: string]: * };

  declare export type OptionsStruct = { [key: string]: * };

  declare export type ExecaOptions = {|
    argv0?: string,
    cleanup?: boolean,
    cwd?: string,
    detached?: boolean,
    encoding?: string,
    env?: { [key: string]: string },
    extendEnv?: boolean,
    gid?: number,
    input?: string | Buffer,
    killSignal?: string | number,
    localDir?: string,
    maxBuffer?: number,
    preferLocal?: boolean,
    reject?: boolean,
    shell?: boolean | string,
    stderr?: string | number | stream$Duplex,
    stdin?: string | number | stream$Duplex,
    stdio?: string,
    stdout?: string | number | stream$Duplex,
    stripEof?: boolean,
    timeout?: number,
    uid?: number,
    windowsVerbatimArguments?: boolean,
  |};

  declare export type ConsoleOptions = {|
    debug: boolean,
    footer: string,
    header: string,
    silent: boolean,
  |};

  declare export type EventArguments = *[];

  declare export type EventListener = (...args: EventArguments) => void;

  declare export type EventNextHandler = (index: number, ...args: EventArguments) => void;

  declare export type PackageConfig = {
    name: string,
    version: string,
  };

  declare export type Status = 'pending' | 'running' | 'skipped' | 'passed' | 'failed';

  declare export type TaskAction<Tx> = (value: *, context: Tx) => Promise<*>;

  declare export type ToolConfig = {
    debug: boolean,
    extends: string | string[],
    plugins: string[],
    reporter: string,
    silent: boolean,
    [key: string]: *,
  };

  declare export type ToolOptions = {|
    appName: string,
    configBlueprint: Blueprint,
    configFolder: string,
    extendArgv: string,
    footer: string,
    header: string,
    pluginAlias: string,
    root: string,
    scoped: boolean,
  |};

  declare export class ConfigLoader {
    package: PackageConfig;
    parsedFiles: { [path: string]: boolean };
    tool: Tool<*, *>;

    constructor(tool: Tool<*, *>): this;
    loadConfig(): ToolConfig;
    loadPackageJSON(): PackageConfig;
    parseAndExtend(fileOrConfig: string | ConfigStruct): ConfigStruct;
    parseFile(filePath: string, options?: OptionsStruct): OptionsStruct;
    resolveExtendPaths(extendPaths: string[], baseDir?: string): string[];
    resolveModuleConfigPath(appName: string, moduleName: string, preset?: boolean, ext?: string): string;
  }

  declare export class Module<To> {
    moduleName: string;
    name: string;
    options: To;

    constructor(options?: To): this;
  }

  declare export class ModuleLoader<Tm> {
    classReference: Class<Tm>;
    tool: Tool<*, *>;
    typeName: string;

    constructor(tool: Tool<*, *>, typeName: string, classReference: Class<Tm>): this;
    importModule(name: string, options?: OptionsStruct): Tm;
    importModuleFromOptions(baseOptions: OptionsStruct): Tm;
    loadModule(module: string | OptionsStruct | Tm): Tm;
    loadModules(modules: (string | OptionsStruct | Tm)[]): Tm[];
  }

  declare export class Plugin<To> extends Module<To> {
    priority: number;
    tool: Tool<*, *>;

    bootstrap(): void;
  }

  declare export type ReportLoader = () => {|
    debug: boolean,
    debugs: string[],
    errors: string[],
    footer: string,
    header: string,
    logs: string[],
    silent: boolean,
    tasks: Task<*, *>[],
  |};

  declare export class Reporter<To> extends Module<To> {
    instance: number;
    loader: ?ReportLoader;

    indent(length: number): string;
    render(code?: number): string;
    renderTask(task: Task<*, *>, level?: number, suffix?: string): string[];
    renderStatus(task: Task<*, *>): string;
    start(loader: ReportLoader): void;
    stop(): void;
    update(): void;
  }

  declare export default class ExitError extends Error {
    code: number;

    constructor(message: string, code?: number): this;
  }

  declare export default class Console<Tr: Reporter<*>> {
    debugs: string[];
    debugGroups: string[];
    debugIndex: number;
    errors: string[];
    interrupted: boolean;
    logs: string[];
    options: ConsoleOptions;
    reporter: Tr;

    constructor(reporter: Tr, options?: $Shape<ConsoleOptions>): this;
    debug(message: string): void;
    error(message: string): void;
    exit(message: string | Error | null, code?: number): void;
    log(message: string): void;
    start(tasks?: Task<*, *>[]): void;
    startDebugGroup(group: string): void;
    stop(): void;
    stopDebugGroup(): void;
    update(): void;
  }

  declare export class Event {
    name: string;
    next: ?EventNextHandler;
    stopped: boolean;
    time: number;
    value: *;

    constructor(name: string, value?: *): this;
    stop(): void;
  }

  declare export class Emitter {
    listeners: { [eventName: string]: Set<EventListener> };
    namespace: string;

    createEventName(name: string): string;
    emit(name: string, args?: EventArguments, initialValue?: *): Event;
    emitCascade(name: string, args?: EventArguments, initialValue?: *): Event;
    getEventNames(): string[];
    getListeners(eventName: string): Set<EventListener>;
    off(eventName: string, listener: EventListener): this;
    on(eventName: string, listener: EventListener): this;
    setEventNamespace(namespace: string): this;
    removeEventNamespace(): this;
  }

  declare export class Tool<Tp: Plugin<*>, Tr: Reporter<*>> extends Emitter {
    argv: string[];
    config: ToolConfig;
    configLoader: ConfigLoader;
    console: Console<Tr>;
    initialized: boolean;
    options: ToolOptions;
    package: PackageConfig;
    pluginLoader: ModuleLoader<Tp>;
    plugins: Tp[];

    constructor(options: $Shape<ToolOptions>, argv?: string[]): this;
    debug(message: string): this;
    exit(message: string | Error | null, code?: number): this;
    getPlugin(name: string): Tp;
    initialize(): this;
    invariant(condition: boolean, message: string, pass: string, fail: string): this;
    loadConfig(): this;
    loadPlugins(): this;
    loadReporter(): this;
    log(message: string): this;
    logError(message: string): this;
  }

  declare export class Task<Tc, Tx> {
    action: ?TaskAction<Tx>;
    config: Tc;
    context: Tx;
    frame: number;
    title: string;
    status: Status;
    subroutines: Task<*, Tx>[];
    subtasks: Task<*, Tx>[];

    constructor(title: string, action?: ?TaskAction<Tx>, defaultConfig?: Tc): this;
    hasFailed(): boolean;
    hasPassed(): boolean;
    isPending(): boolean;
    isRunning(): boolean;
    isSkipped(): boolean;
    run(value: *, context: Tx): Promise<*>;
    skip(condition?: boolean): this;
    wrap(value: *): Promise<*>;
  }

  declare export class Routine<Tc, Tx> extends Task<Tc, Tx> {
    key: string;
    tool: Tool<*, Reporter<*>>;

    constructor(key: string, title: string, defaultConfig?: Tc): this;
    bootstrap(): void;
    configure(parent: Routine<*, Tx>): this;
    execute(value: *, context?: Tx): Promise<*>;
    executeCommand(command: string, args: string[], options?: $Shape<ExecaOptions>): Promise<*>;
    executeTask(value: *, task: Task<*, Tx>): Promise<*>;
    parallelizeSubroutines(value: *): Promise<*>;
    parallelizeTasks(value: *): Promise<*>;
    pipe(routine: Routine<*, Tx>): this;
    serialize(
      initialValue: *,
      items: *[],
      accumulator:(value: *, item: *) => Promise<*>,
    ): Promise<*>;
    serializeSubroutines(value: *): Promise<*>;
    serializeTasks(value: *): Promise<*>;
    task<C>(title: string, action: TaskAction<Tx>, config?: C): Task<C, Tx>;
  }

  declare export class Pipeline<Tp: Plugin<*>, Tx> extends Routine<ToolConfig, Tx> {
    constructor(tool: Tool<Tp, Reporter<*>>): this;
  }
}
