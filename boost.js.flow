declare module 'boost' {
  declare export type EventArguments = *[];

  declare export type EventListener = (...args: EventArguments) => void;

  declare export type EventNextHandler = (index: number, ...args: EventArguments) => void;

  declare export type PackageConfig = {
    name: string,
    version: string,
  };

  declare export type Status = 'pending' | 'running' | 'skipped' | 'passed' | 'failed';

  declare export type TaskAction<Tx> = (value: *, context: Tx) => Promise<*>;

  declare export type ToolConfig = {
    debug: boolean,
    extends: string | string[],
    plugins: string[],
    reporter: string,
    silent: boolean,
    [key: string]: *,
  };

  declare export type ToolOptions = {
    appName: string,
    footer: string,
    header: string,
    pluginAlias: string,
    root: string,
    scoped: boolean,
  };

  declare class ConfigLoader {
    options: ToolOptions;
    package: PackageConfig;
    parsedFiles: { [path: string]: boolean };

    constructor(options: ToolOptions): this;
    loadConfig(): ToolConfig;
    loadPackageJSON(): PackageConfig;
    parseAndExtend(fileOrConfig: string | Object): Object;
    parseFile(filePath: string, options?: Object): Object;
    resolveExtendPaths(extendPaths: string[], baseDir?: string): string[];
    resolveModuleConfigPath(appName: string, moduleName: string, preset?: boolean, ext?: string): string;
  }

  declare class Module<To: Object = {}> {
    moduleName: string;
    name: string;
    options: To;

    constructor(options?: To): this;
  }

  declare class ModuleLoader<Tm> {
    classReference: Class<Tm>;
    options: ToolOptions;
    typeName: string;

    constructor(typeName: string, classReference: Class<Tm>, options: ToolOptions): this;
    importModule(name: string, options?: Object): Tm;
    importModuleFromOptions(baseOptions: Object): Tm;
    loadModule(module: string | Object | Tm): Tm;
    loadModules(modules: (string | Object | Tm)[]): Tm[];
  }

  declare export class Plugin<To: Object = {}> extends Module<To> {
    priority: number;
    tool: Tool<*, *>;

    bootstrap(): void;
  }

  declare export type ReportLoader = () => {
    debug: boolean,
    debugs: string[],
    errors: string[],
    footer: string,
    header: string,
    logs: string[],
    silent: boolean,
    tasks: Task<Object, Object>[],
  };

  declare export class Reporter<To: Object = {}> extends Module<To> {
    instance: number;
    loader: ?ReportLoader;

    indent(length: number): string;
    render(code?: number): string;
    renderTask(task: Task<Object, Object>, level?: number, suffix?: string): string[];
    renderStatus(task: Task<Object, Object>): string;
    start(loader: ReportLoader): void;
    stop(): void;
    update(): void;
  }

  declare export default class ExitError extends Error {
    code: number;

    constructor(message: string, code?: number): this;
  }

  declare export default class Console<Tr: Reporter<Object>> {
    debugs: string[];
    debugGroups: string[];
    debugIndex: number;
    errors: string[];
    interrupted: boolean;
    logs: string[];
    reporter: Tr;

    constructor(reporter: Tr): this;
    debug(message: string): void;
    error(message: string): void;
    exit(message: string | Error | null, code?: number): void;
    log(message: string): void;
    start(config: ToolConfig, options: ToolOptions, tasks: Task<*, *>[]): void;
    startDebugGroup(group: string): void;
    stop(): void;
    stopDebugGroup(): void;
    update(): void;
  }

  declare export class Event {
    name: string;
    next: ?EventNextHandler;
    stopped: boolean;
    time: number;
    value: *;

    constructor(name: string, value?: *): this;
    stop(): void;
  }

  declare export class Emitter {
    listeners: { [eventName: string]: Set<EventListener> };

    emit(eventName: string, args?: EventArguments, initialValue?: *): Event;
    emitCascade(eventName: string, args?: EventArguments, initialValue?: *): Event;
    getEventNames(): string[];
    getListeners(eventName: string): Set<EventListener>;
    off(eventName: string, listener: EventListener): this;
    on(eventName: string, listener: EventListener): this;
  }

  declare export class Tool<Tp: Plugin<Object>, Tr: Reporter<Object>> extends Emitter {
    config: ToolConfig;
    configLoader: ConfigLoader;
    console: Console<Tr>;
    initialized: boolean;
    options: ToolOptions;
    package: PackageConfig;
    pluginLoader: ModuleLoader<Tp>;
    plugins: Tp[];
    reporter: Tr;
    reporterLoader: ModuleLoader<Tr>;

    constructor(options: Object): this;
    debug(message: string): this;
    exit(message: string | Error, code?: number): this;
    getPlugin(name: string): Tp;
    initialize(): this;
    invariant(condition: boolean, message: string, pass: string, fail: string): this;
    loadConfig(): this;
    loadPlugins(): this;
    loadReporter(): this;
    log(message: string): this;
    logError(message: string): this;
  }

  declare export class Task<Tc: Object = {}, Tx: Object = {}> {
    action: ?TaskAction<Tx>;
    config: Tc;
    context: Tx;
    frame: number;
    title: string;
    status: Status;
    subroutines: Task<Object, Tx>[];
    subtasks: Task<Object, Tx>[];

    constructor(title: string, action?: ?TaskAction<Tx>, defaultConfig?: Tc): this;
    hasFailed(): boolean;
    hasPassed(): boolean;
    isPending(): boolean;
    isRunning(): boolean;
    isSkipped(): boolean;
    run(value: *, context?: Tx): Promise<*>;
    skip(condition?: boolean): this;
    wrap(value: *): Promise<*>;
  }

  declare export class Routine<Tc: Object = {}, Tx: Object = {}> extends Task<Tc, Tx> {
    key: string;
    tool: Tool<*, Reporter<Object>>;

    constructor(key: string, title: string, defaultConfig?: Tc): this;
    bootstrap(): void;
    configure(parent: Routine<*, Tx>): this;
    execute(value: *, context?: Tx): Promise<*>;
    executeCommand(command: string, args: string[], options?: Object): Promise<*>;
    executeTask(value: *, task: Task<Object, Tx>): Promise<*>;
    parallelizeSubroutines(value: *): Promise<*>;
    parallelizeTasks(value: *): Promise<*>;
    pipe(routine: Routine<Object, Tx>): this;
    serialize(
      initialValue: *,
      items: *[],
      accumulator:(value: *, item: *) => Promise<*>,
    ): Promise<*>;
    serializeSubroutines(value: *): Promise<*>;
    serializeTasks(value: *): Promise<*>;
    task(title: string, action: TaskAction<Tx>, config?: Object): Task<Object, Tx>;
  }

  declare export class Pipeline<Tp: Plugin<Object>, Tx: Object = {}> extends Routine<ToolConfig, Tx> {
    constructor(tool: Tool<Tp, Reporter<Object>>): this;
  }
}
