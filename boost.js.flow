declare module 'boost' {
  declare export type EventArguments = *[];

  declare export type EventListener = (...args: EventArguments) => void;

  declare export type EventNextHandler = (index: number, ...args: EventArguments) => void;

  declare export type PackageConfig = {
    name: string,
    version: string,
  };

  declare export type Result = *;

  declare export type ResultPromise = Promise<Result>;

  declare export type ResultAccumulator<T> = (value: Result, item: T) => ResultPromise;

  declare export type Status = 'pending' | 'running' | 'skipped' | 'passed' | 'failed';

  declare export type TaskCallback = (value: Result, context?: Object) => Result | ResultPromise;

  declare export type TasksLoader = () => Task<*>[];

  declare export type ToolConfig = {
    debug: boolean,
    extends: string | string[],
    silent: boolean,
    [key: string]: *,
  };

  declare export type ToolOptions = {
    appName: string,
    pluginName: string,
    renderer: Renderer,
    root: string,
  };

  declare class ConfigLoader {
    config: ToolConfig;
    options: ToolOptions;
    package: PackageConfig;
    parsedFiles: { [key: string]: boolean };

    constructor(options: ToolOptions): this;
    loadConfig(): ToolConfig;
    loadPackageJSON(): PackageConfig;
    parseAndExtend(fileOrConfig: string | Object): Object;
    parseFile(filePath: string, options?: Object): Object;
    resolveExtendPaths(extendPaths: string | string[], baseDir?: string): string[];
    resolveModuleConfigPath(appName: string, moduleName: string, preset?: boolean, ext?: string): string;
  }

  declare class PluginLoader<TP: Plugin<*>> {
    options: ToolOptions;
    plugins: TP[];

    constructor(options: ToolOptions): this;
    importPlugin(name: string, options?: Object): TP;
    importPluginFromOptions(baseOptions: Object): TP;
    loadPlugins(plugins: (string | TP)[]): TP[];
    sortPlugins(): this;
  }

  declare export class Plugin<T: Object> {
    moduleName: string;
    name: string;
    options: T;
    priority: number;
    tool: Tool<*, *>;

    constructor(options?: T): this;
    bootstrap(): void;
  }

  declare export type RendererOptions = {
    clearOutput: boolean,
    refreshRate: number,
  };

  declare export class Renderer {
    instance: number;
    hasFailed: boolean;
    loader: ?TasksLoader;
    options: RendererOptions;
    tool: Tool<*, *>;

    constructor(options?: Object): this;
    indent(length: number): string;
    render(tasks: Task<*>[]): string;
    renderTask(task: Task<*>, level?: number, suffix?: string): string[];
    renderStatus(task: Task<*>): string;
    start(loader: TasksLoader): void;
    stop(): void;
    update(stop?: boolean): false;
  }

  declare export class Event {
    name: string;
    next: ?EventNextHandler;
    stopped: boolean;
    time: number;
    value: *;

    constructor(name: string, value?: *): this;
    stop(): void;
  }

  declare export class Emitter {
    listeners: { [eventName: string]: Set<EventListener> };

    emit(eventName: string, initialValue: Result, args?: EventArguments): Event;
    emitCascade(eventName: string, initialValue: Result, args?: EventArguments): Event;
    getEventNames(): string[];
    getListeners(eventName: string): Set<EventListener>;
    off(eventName: string, listener: EventListener): this;
    on(eventName: string, listener: EventListener): this;
  }

  declare export class Tool<TP: Plugin<*>, TR: Renderer> extends Emitter {
    config: ToolConfig;
    configLoader: ConfigLoader;
    debugs: string[];
    debugGroups: string[];
    errors: string[];
    initialized: boolean;
    logs: string[];
    options: ToolOptions;
    package: PackageConfig;
    pluginLoader: PluginLoader<TP>;
    plugins: TP[];
    renderer: TR;

    constructor(options: Object): this;
    closeConsole(): this;
    debug(message: string): this;
    getPlugin(name: string): TP;
    initialize(): this;
    invariant(condition: boolean, message: string, pass: string, fail: string): this;
    loadConfig(): this;
    log(message: string): this;
    logError(message: string): this;
    loadPlugins(): this;
    openConsole(loader: TasksLoader): this;
    render(): this;
    startDebugGroup(group: string): this;
    stopDebugGroup(): this;
  }

  declare export class Task<T: Object> {
    action: ?TaskCallback;
    config: T;
    context: Object;
    frame: number;
    title: string;
    status: Status;
    subroutines: Task<*>[];
    subtasks: Task<*>[];

    constructor(title: string, action?: ?TaskCallback, defaultConfig?: T): this;
    hasFailed(): boolean;
    hasPassed(): boolean;
    isPending(): boolean;
    isRunning(): boolean;
    isSkipped(): boolean;
    run(value: Result, context?: Object): ResultPromise;
    skip(condition?: boolean): this;
    wrap(value: *): ResultPromise;
  }

  declare export class Routine<T: Object> extends Task<T> {
    key: string;
    tool: Tool<*, *>;

    constructor(key: string, title: string, defaultConfig?: T): this;
    bootstrap(): void;
    configure(parent: Routine<*>): this;
    execute(value: Result, context?: Object): ResultPromise;
    executeCommand(command: string, args: string[], options?: Object): ResultPromise;
    executeTask(value: Result, task: Task<*>): ResultPromise;
    parallelizeSubroutines(value: Result): ResultPromise;
    parallelizeTasks(value: Result): ResultPromise;
    pipe(...routines: Routine<*>[]): this;
    serialize<I>(initialValue: Result, items: I[], accumulator: ResultAccumulator<I>): ResultPromise;
    serializeSubroutines(value: Result): ResultPromise;
    serializeTasks(value: Result): ResultPromise;
    task<C>(title: string, action: TaskCallback, config?: C): Task<C>;
  }

  declare export class Pipeline<TP: Plugin<*>, TR: Renderer> extends Routine<ToolConfig> {
    tool: Tool<TP, TR>;

    constructor(tool: Tool<TP, TR>): this;
    loadTasks(): Routine<*>[];
  }
}
