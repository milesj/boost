(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{76:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return p})),t.d(n,"rightToc",(function(){return b})),t.d(n,"default",(function(){return d}));var a=t(2),r=t(6),o=(t(0),t(85)),i=t(92),s=t(90),l=t(91),c={title:"Arguments"},p={unversionedId:"args",id:"args",isDocsHomePage:!1,title:"Arguments",description:"A type-safe and convention based argument parsing library, with strict validation checks.",source:"@site/docs/args.mdx",permalink:"/docs/args",editUrl:"https://github.com/milesj/boost/edit/master/website/docs/args.mdx",sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/"},next:{title:"CLIs",permalink:"/docs/cli"}},b=[{value:"Installation",id:"installation",children:[]},{value:"Parsing",id:"parsing",children:[{value:"Contextual parsing",id:"contextual-parsing",children:[]}]},{value:"Commands",id:"commands",children:[]},{value:"Options",id:"options",children:[{value:"Single value",id:"single-value",children:[]},{value:"Multiple values",id:"multiple-values",children:[]},{value:"Unknown options",id:"unknown-options",children:[]}]},{value:"Flags",id:"flags",children:[]},{value:"Params",id:"params",children:[{value:"Variadic params",id:"variadic-params",children:[]}]},{value:"Rest args",id:"rest-args",children:[]},{value:"Advanced",id:"advanced",children:[{value:"Short option groups",id:"short-option-groups",children:[]},{value:"Counter options",id:"counter-options",children:[]},{value:"Choice options",id:"choice-options",children:[]},{value:"Arity requirements",id:"arity-requirements",children:[]},{value:"Command &amp; option categories",id:"command--option-categories",children:[]}]},{value:"Type casting",id:"type-casting",children:[]},{value:"Validation checks",id:"validation-checks",children:[]},{value:"Formatting args",id:"formatting-args",children:[]}],u={rightToc:b};function d(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)(i.a,{tooling:!0,mdxType:"EnvBadges"}),Object(o.b)("p",null,"A type-safe and convention based argument parsing library, with strict validation checks."),Object(o.b)("h2",{id:"installation"},"Installation"),Object(o.b)(s.a,{groupId:"package-manager",defaultValue:"yarn",values:[{label:"Yarn",value:"yarn"},{label:"NPM",value:"npm"}],mdxType:"Tabs"},Object(o.b)(l.a,{value:"yarn",mdxType:"TabItem"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"yarn add @boost/args\n"))),Object(o.b)(l.a,{value:"npm",mdxType:"TabItem"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"npm install @boost/args\n")))),Object(o.b)("h2",{id:"parsing"},"Parsing"),Object(o.b)("p",null,"This library is strict parser for command line arguments, primarily ",Object(o.b)("inlineCode",{parentName:"p"},"process.argv")," in Node.js, that\nsupports ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#commands"}),"commands"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#options"}),"options"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#flags"}),"flags"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#params"}),"params"),", and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#advanced-features"}),"much more"),"! It is ",Object(o.b)("em",{parentName:"p"},"not")," a command line interface or application but provides\nthe building blocks for such functionality."),Object(o.b)("p",null,"Parsing arguments is accomplished with the ",Object(o.b)("inlineCode",{parentName:"p"},"parse()")," function, which requires a list of strings\n(arguments also known as ",Object(o.b)("inlineCode",{parentName:"p"},"argv"),"), and a settings object to control whats supported. It also utilizes\nTypeScript generics to type options and params respectively."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { parse } from '@boost/args';\n\n// Remove node binary and script\nconst argv = process.argv.slice(2);\n\n// Parse argv into a consumable object\nconst { command, errors, options, params, rest } = parse<{ help: boolean }, [string]>(argv, {\n  options: {\n    help: {\n      description: 'Show the help menu',\n      short: 'H',\n      type: 'boolean',\n    },\n  },\n  params: [\n    {\n      description: 'File path to source directory',\n      label: 'Source',\n      required: true,\n      type: 'string',\n    },\n  ],\n});\n")),Object(o.b)("p",null,"A command line breaks down to the following parts. This terminology pertains to Boost but is based\non common patterns seen throughout the community."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"\u250c 1 \u2510 \u250c 2 \u2510 \u250c\u2500\u2500\u2500 3 \u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500 4 \u2500\u2500\u2500\u2510 \u250c\u2500\u2500 5 \u2500\u2510 \u250c 6 \u2510 \u250c\u2500\u2500\u2500 7 \u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500 8 \u2500\u2500\u2500\u2500\u2510\nboost build --key value --key=value -flag -F -aBDc foo bar baz -- --foo bar -B\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 9 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Binary that was executed. Also known as a script, and is never passed to ",Object(o.b)("inlineCode",{parentName:"li"},"argv"),"."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#commands"}),"Command")," being executed. Should always be first."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#options"}),"Option")," with a value."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#options"}),"Option")," with a value using an equals sign."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#flags"}),"Flag")," in both long and short form."),Object(o.b)("li",{parentName:"ol"},"A group of ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#short-option-groups"}),"short options"),", most commonly used by flags."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#params"}),"Parameters")," passed to a command."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#rest-args"}),"Rest")," arguments that are not parsed. Always appear after a ",Object(o.b)("inlineCode",{parentName:"li"},"--"),"."),Object(o.b)("li",{parentName:"ol"},"The command line.")),Object(o.b)("h3",{id:"contextual-parsing"},"Contextual parsing"),Object(o.b)("p",null,"While the above is straight forward (I hope so), it doesn't leave much room for customization. What\nif we want different options based on the command passed? Or different params? Or how to handle\nglobal options? So on and so forth."),Object(o.b)("p",null,"To provide this functionality, the ",Object(o.b)("inlineCode",{parentName:"p"},"parseInContext()")," function can be used. Like ",Object(o.b)("inlineCode",{parentName:"p"},"parse()"),", this\nfunction requires a list of strings (",Object(o.b)("inlineCode",{parentName:"p"},"argv"),"), but unlike, it requires a factory function that\nreturns contextual parser options."),Object(o.b)("p",null,"The parser will loop through each argument, executing the factory function with the argument and\nargv list, until a match is found and options were returned."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { parseInContext } from '@boost/args';\n\n// Remove node binary and script\nconst argv = process.argv.slice(2);\n\n// Parse argv into a consumable object\nconst { command, errors, options, params, rest } = parseInContext(argv, (arg) => {\n  // Build command found, define build specific options\n  if (arg === 'build') {\n    return {\n      command: ['build'],\n      options: {\n        dest: {\n          description: 'Destination path',\n          type: 'string',\n        },\n      },\n    };\n  }\n\n  // Install command found, require params\n  if (arg === 'install') {\n    return {\n      command: ['install'],\n      params: [\n        {\n          description: 'Package name(s)',\n          type: 'string',\n          required: true,\n        },\n      ],\n    };\n  }\n\n  return undefined;\n});\n")),Object(o.b)("h2",{id:"commands"},"Commands"),Object(o.b)("p",null,"Commands are a feature that allow for branching logic, full isolation, and distinct code paths. That\nbeing said, the parser does not handle this functionality, as that's a CLI/programs job. The parser\nhowever, will detect a command, and sub-commands, and validate them accordingly."),Object(o.b)("p",null,"A command in Boost should be the first argument passed, before ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#options"}),"options"),", and definitely\nbefore ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#params"}),"params"),". They support numbers, letters, and dashes, with sub-commands being\nseparated by a colon (",Object(o.b)("inlineCode",{parentName:"p"},":"),")."),Object(o.b)("p",null,"To detect and parse commands, pass a list of all command and sub-command names to the ",Object(o.b)("inlineCode",{parentName:"p"},"commands"),"\nsetting, or use a custom function to manually do the checks. The detected command will be returned\nas an array, split on ",Object(o.b)("inlineCode",{parentName:"p"},":"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const args = parse<{}>(argv, {\n  commands: ['build', 'build:esm', 'build:cjs', 'install'],\n  // OR\n  commands(arg) {\n    return arg === 'build'; // etc\n  },\n});\n\n// build:esm src/ --out lib/\nargs.command; // ['build', 'esm']\nargs.options; // { out: 'lib/' }\nargs.params; // ['src/']\n")),Object(o.b)("p",null,"If an argument is not found in the commands list or function, it will be treated as a parameter."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// build:umd src/ --out lib/\nargs.command; // []\nargs.options; // { out: 'lib/' }\nargs.params; // ['build:umd', 'src/']\n")),Object(o.b)("h2",{id:"options"},"Options"),Object(o.b)("p",null,"An option is an optional argument that accepts a single value or multiple values. It has 2 forms,\nthe first being the default form, also known as a long option, which starts with ",Object(o.b)("inlineCode",{parentName:"p"},"--")," and is\nfollowed by a word or phrase (either in camel or kebab case). For example, ",Object(o.b)("inlineCode",{parentName:"p"},"--log"),", ",Object(o.b)("inlineCode",{parentName:"p"},"--log-level"),",\nor ",Object(o.b)("inlineCode",{parentName:"p"},"--logLevel")," (preferred)."),Object(o.b)("p",null,"The second form is known as the short form and is represented by a single alpha character (either\nlower or uppercase) prefixed with ",Object(o.b)("inlineCode",{parentName:"p"},"-"),", for example, ",Object(o.b)("inlineCode",{parentName:"p"},"-l")," or ",Object(o.b)("inlineCode",{parentName:"p"},"-L"),". The short option can be enabled\nwith the ",Object(o.b)("inlineCode",{parentName:"p"},"short")," setting."),Object(o.b)("p",null,"For options to parse correctly, they must be defined using a settings object. Each option supports\nthe following settings:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"type")," (",Object(o.b)("inlineCode",{parentName:"li"},"'boolean' | 'number' | 'string'"),") - Expected type of the provided value. When a value is\ncaptured from the command line, it will be type casted. ",Object(o.b)("em",{parentName:"li"},"(Required)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"category")," (",Object(o.b)("inlineCode",{parentName:"li"},"string"),") - A unique key to group options within categories. Couples with the\n",Object(o.b)("inlineCode",{parentName:"li"},"Category")," type."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"description")," (",Object(o.b)("inlineCode",{parentName:"li"},"string"),") - A description of what the option does. Primarily used in interface\noutput. ",Object(o.b)("em",{parentName:"li"},"(Required)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"default")," (",Object(o.b)("inlineCode",{parentName:"li"},"*"),") - The default value if option not provided on the command line. The value's type\nis dependent on the ",Object(o.b)("inlineCode",{parentName:"li"},"type")," and ",Object(o.b)("inlineCode",{parentName:"li"},"multiple")," settings. Furthermore, this value defaults to the\nfollowing if not defined.",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"A zero (",Object(o.b)("inlineCode",{parentName:"li"},"0"),") when type is ",Object(o.b)("inlineCode",{parentName:"li"},"number"),"."),Object(o.b)("li",{parentName:"ul"},"An empty string (",Object(o.b)("inlineCode",{parentName:"li"},"''"),") when type is ",Object(o.b)("inlineCode",{parentName:"li"},"string"),"."),Object(o.b)("li",{parentName:"ul"},"And ",Object(o.b)("inlineCode",{parentName:"li"},"false")," when type is ",Object(o.b)("inlineCode",{parentName:"li"},"boolean"),"."))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"format")," (",Object(o.b)("inlineCode",{parentName:"li"},"(value: T) => T"),") - An optional function to format the value after parsing. Must return\nthe same type."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"hidden")," (",Object(o.b)("inlineCode",{parentName:"li"},"boolean"),") - Hide the option from interface output. Defaults to ",Object(o.b)("inlineCode",{parentName:"li"},"false"),"."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"short")," (",Object(o.b)("inlineCode",{parentName:"li"},"string"),") - Single character used as a the short option alias."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"usage")," (",Object(o.b)("inlineCode",{parentName:"li"},"string"),") - Example instructions on how to use the option."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"validate")," (",Object(o.b)("inlineCode",{parentName:"li"},"(value: T) => void"),") - An optional function to validate the provided value.")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const argv = ['--logLevel=2'];\nconst args = parse<{ logLevel: number }>(argv, {\n  options: {\n    logLevel: {\n      description: 'Increase log output verbosity',\n      type: 'number',\n      short: 'L',\n      validate(value) {\n        if (value < 0 || value > 10) {\n          throw new Error('Log level must be between 0 and 10.');\n        }\n      },\n    },\n  },\n});\n\nargs.options.logLevel; // 2\n")),Object(o.b)("p",null,"The name of options used on the command line are derived from the ",Object(o.b)("inlineCode",{parentName:"p"},"options")," keys (above), which are\npreferred to be camel case. Even though they are defined as camel case, kebab case variants are\nsupported on the command line."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"When using TypeScript, a mapping of option names to expected types is defined as the 1st generic\nslot of ",Object(o.b)("inlineCode",{parentName:"p"},"parse()"),". If not provided, it defaults to ",Object(o.b)("inlineCode",{parentName:"p"},"object"),". It's highly encouraged to type\noptions correctly.")),Object(o.b)("h3",{id:"single-value"},"Single value"),Object(o.b)("p",null,"A value can be passed as either an additional argument separated by a space, like ",Object(o.b)("inlineCode",{parentName:"p"},"--option value"),"\n(preferred), or with an equals sign and no space (also known as an inline value), like\n",Object(o.b)("inlineCode",{parentName:"p"},"--option=value"),"."),Object(o.b)("p",null,"If you are passing a string that contains spaces or special characters, you must wrap the value in\ndouble quotes. For example, ",Object(o.b)("inlineCode",{parentName:"p"},'--option "long value"')," or ",Object(o.b)("inlineCode",{parentName:"p"},'--option="long value"'),"."),Object(o.b)("h3",{id:"multiple-values"},"Multiple values"),Object(o.b)("p",null,"To pass multiple values for an option, the ",Object(o.b)("inlineCode",{parentName:"p"},"multiple")," setting must be enabled (numbers and strings\nonly), and if using TypeScript, the option type must be a typed array."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const args = parse<{ files: string[] }>(argv, {\n  options: {\n    files: {\n      description: 'List of files to process',\n      multiple: true,\n      type: 'string',\n    },\n  },\n});\n")),Object(o.b)("p",null,"Like single values, there are 2 patterns for passing multiple values, but the semantics are slightly\ndifferent. When using inlines values (the equals sign), the option must be repeated for each value,\nlike ",Object(o.b)("inlineCode",{parentName:"p"},"--option=foo --option=bar --option=baz"),"."),Object(o.b)("p",null,"Otherwise, each value can be passed as a standalone argument, like ",Object(o.b)("inlineCode",{parentName:"p"},"--option foo bar baz"),". When\nusing this approach, all values will be captured until another option is passed, or the end of the\nlist is met."),Object(o.b)("h3",{id:"unknown-options"},"Unknown options"),Object(o.b)("p",null,"If an option is passed to ",Object(o.b)("inlineCode",{parentName:"p"},"parse()")," that is not configured in the ",Object(o.b)("inlineCode",{parentName:"p"},"options")," settings object, it will\nbe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#validation-checks"}),"logged as a parse error")," unless the ",Object(o.b)("inlineCode",{parentName:"p"},"unknown")," setting is set to true. When\ntrue, all unknown options can be found in the result's ",Object(o.b)("inlineCode",{parentName:"p"},"unknown")," object and not in ",Object(o.b)("inlineCode",{parentName:"p"},"options"),", as a\nmeans to avoid collision."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const argv = ['--legit', 'foo', '--unknown', 'bar'];\nconst args = parse<{ legit: string }>(argv, {\n  options: {\n    legit: {\n      description: 'A legitimate option',\n      type: 'string',\n    },\n  },\n  unknown: true,\n});\n\nargs.options; // { legit: 'foo' }\nargs.unknown; // { unknown: 'bar' }\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Unknown short options will still throw an error, as they require a parent long option to\nreference.")),Object(o.b)("h2",{id:"flags"},"Flags"),Object(o.b)("p",null,"A flag is a special type of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#options"}),"option")," that accepts no value, is always boolean, and\nrepresents a binary on-off switch. When the flag is passed on the command line (without a value),\nfor example, ",Object(o.b)("inlineCode",{parentName:"p"},"--color"),", the value is assumed to be ",Object(o.b)("inlineCode",{parentName:"p"},"true"),". To negate a truthy value and pass a falsy\none, prefix the option with ",Object(o.b)("inlineCode",{parentName:"p"},"no-"),", for example, ",Object(o.b)("inlineCode",{parentName:"p"},"--no-color"),"."),Object(o.b)("p",null,"Each flag supports the ",Object(o.b)("inlineCode",{parentName:"p"},"type")," (required), ",Object(o.b)("inlineCode",{parentName:"p"},"description")," (required), ",Object(o.b)("inlineCode",{parentName:"p"},"default")," (is ",Object(o.b)("inlineCode",{parentName:"p"},"false")," if not\nprovided), ",Object(o.b)("inlineCode",{parentName:"p"},"hidden"),", ",Object(o.b)("inlineCode",{parentName:"p"},"usage"),", and ",Object(o.b)("inlineCode",{parentName:"p"},"short")," settings mentioned above."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const argv = ['--color'];\nconst args = parse<{ color: boolean }>(argv, {\n  options: {\n    color: {\n      description: 'Enable colored output',\n      type: 'boolean',\n    },\n  },\n});\n\nargs.options.color; // true\n")),Object(o.b)("h2",{id:"params"},"Params"),Object(o.b)("p",null,"Parameters (or positional arguments) are standalone arguments that are treated as values, and are\nparsed in a strict order. They're an important mechanism that serves 2 purposes."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"They're a catch all bucket for arguments that ",Object(o.b)("em",{parentName:"li"},"are not")," a command, option, or flag, nor do they\nappear after a rest ",Object(o.b)("inlineCode",{parentName:"li"},"--")," delimiter."),Object(o.b)("li",{parentName:"ul"},"They're tightly coupled to commands (when being used). Think of a command as a function, where the\nparams are the arguments that are passed to the function.")),Object(o.b)("p",null,"Like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#options"}),"options"),", params can be configured, but unlike options, the settings are not\nrequired. When a setting is not defined, a param is treated as a string. Params support similar\nsettings as options, with the addition of:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"default"),", ",Object(o.b)("inlineCode",{parentName:"li"},"deprecated"),", ",Object(o.b)("inlineCode",{parentName:"li"},"description"),", ",Object(o.b)("inlineCode",{parentName:"li"},"hidden"),", ",Object(o.b)("inlineCode",{parentName:"li"},"type"),", ",Object(o.b)("inlineCode",{parentName:"li"},"validate")," - Same setting as options."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"label")," (",Object(o.b)("inlineCode",{parentName:"li"},"string"),") - Informational label to display in interface output. ",Object(o.b)("em",{parentName:"li"},"(Required)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"required")," (",Object(o.b)("inlineCode",{parentName:"li"},"boolean"),") - Whether the param is required or not. If required and not passed, the\nparser will throw an error. Defaults to ",Object(o.b)("inlineCode",{parentName:"li"},"false"),".")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const argv = ['off', 'value', '123.45'];\nconst args = parse<{}, [boolean, string, number]>(argv, {\n  params: [\n    {\n      description: 'First parameter',\n      label: 'First',\n      type: 'boolean',\n      required: true,\n    },\n    { description: 'Second parameter', label: 'Second', type: 'string' },\n    { description: 'Third parameter', label: 'Third', type: 'number' },\n  ],\n});\n\nargs.params; // [false, 'value', 123.45]\n")),Object(o.b)("p",null,"Since parameters are order based and not named based, the ",Object(o.b)("inlineCode",{parentName:"p"},"params")," setting is an array, with each\nitem configuring the corresponding position/index (hence the name positional arguments)."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"When using TypeScript, the expected type of each param is defined as a tuple in the 2nd generic\nslot of ",Object(o.b)("inlineCode",{parentName:"p"},"parse()"),". If not provided, it defaults to ",Object(o.b)("inlineCode",{parentName:"p"},"string[]"),".")),Object(o.b)("h3",{id:"variadic-params"},"Variadic params"),Object(o.b)("p",null,"By default the parser enables variadic params, which means that any argument that does not match a\ncommand or option, is considered a param (string only), and is appended to the end of the params\nlist. This also applies to non-configured params."),Object(o.b)("p",null,'As mentioned in the previous section, params are a "catch all bucket", but this only applies when\nthe parser allows variadic params. To disable this functionality, set ',Object(o.b)("inlineCode",{parentName:"p"},"variadic")," to false, which\nwill throw an error on any param that is not explicitly configured. Both of these scenarios are\ndemonstrated below."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// Variadic, appends all params\nconst argv = ['foo', 'bar', 'baz'];\nconst args = parse<{}, [string, string, string]>(argv, {\n  params: [\n    {\n      description: 'First parameter',\n      label: 'First',\n      type: 'string',\n      required: true,\n    },\n  ],\n});\n\nargs.params; // ['foo', 'bar', 'baz']\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// Not variadic, will error for non-configured params\nconst argv = ['foo', 'bar', 'baz'];\nconst args = parse<{}, [string]>(argv, {\n  params: [\n    {\n      description: 'First parameter',\n      label: 'First',\n      type: 'string',\n      required: true,\n    },\n  ],\n  variadic: false,\n});\n\nargs.params; // ['foo']\n")),Object(o.b)("h2",{id:"rest-args"},"Rest args"),Object(o.b)("p",null,"Rest arguments are rather simple, as they're everything after a standalone ",Object(o.b)("inlineCode",{parentName:"p"},"--")," argument (also known\nas ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://unix.stackexchange.com/questions/147143/when-and-how-was-the-double-dash-introduced-as-an-end-of-options-delimiter"}),"end of options delimiter"),"). They are ",Object(o.b)("em",{parentName:"p"},"not")," parsed and are usually passed to\nsubsequent scripts or commands."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const args = parse(['foo', 'bar', '--', 'baz']);\n\nargs.params; // ['foo', 'bar']\nargs.rest; // ['baz']\n")),Object(o.b)("h2",{id:"advanced"},"Advanced"),Object(o.b)("h3",{id:"short-option-groups"},"Short option groups"),Object(o.b)("p",null,"Short options support a shortcut known as a short option group, where multiple short option names\ncan be placed under a single leading ",Object(o.b)("inlineCode",{parentName:"p"},"-"),". For example, instead of passing ",Object(o.b)("inlineCode",{parentName:"p"},"-a -b -c"),", you can pass\n",Object(o.b)("inlineCode",{parentName:"p"},"-abc"),". This shortcut is only available for ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#flags"}),"flags")," (boolean options) and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#counters"}),"counters")," (numeric options with ",Object(o.b)("inlineCode",{parentName:"p"},"count"),"), otherwise an error is thrown."),Object(o.b)("p",null,"When passing flags within a group, it will mark the value as ",Object(o.b)("inlineCode",{parentName:"p"},"true"),". Flag negation is not supported\nwithin a group."),Object(o.b)("h3",{id:"counter-options"},"Counter options"),Object(o.b)("p",null,"Counters are a ",Object(o.b)("inlineCode",{parentName:"p"},"number")," option only feature, where each occurence of the option in a short option\ngroup will increment the option's value (starting from the ",Object(o.b)("inlineCode",{parentName:"p"},"default")," value). For example, passing\n",Object(o.b)("inlineCode",{parentName:"p"},"-vvv"),' will increment the value 3 times, once for each "v", resulting in a sum of 3. If not using a\ngroup, the numeric value will need to be explicitly passed, like ',Object(o.b)("inlineCode",{parentName:"p"},"--verbose 3"),"."),Object(o.b)("p",null,"To make use of this feature, enable the ",Object(o.b)("inlineCode",{parentName:"p"},"count")," setting on a numeric option."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const argv = ['-vvv'];\nconst args = parse<{ verbose: number }>(argv, {\n  options: {\n    verbose: {\n      count: true,\n      default: 0,\n      description: 'Increase output verbosity',\n      short: 'v',\n      type: 'number',\n    },\n  },\n});\n\nargs.options.verbose; // 3\n")),Object(o.b)("h3",{id:"choice-options"},"Choice options"),Object(o.b)("p",null,"For scenarios where you want to only accept an option value from a pre-defined list of choices, the\n",Object(o.b)("inlineCode",{parentName:"p"},"choices")," setting can be used (single number/string values only). If an unsupported value is\nprovided, the parser will throw an error."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const argv = ['--modules', 'umd'];\nconst args = parse<{ modules: 'cjs' | 'esm' | 'umd' }>(argv, {\n  options: {\n    modules: {\n      choices: ['cjs', 'esm', 'umd'] as 'esm'[],\n      default: 'esm',\n      description: 'Choose module output',\n      type: 'string',\n    },\n  },\n});\n\nargs.options.modules; // 'umd'\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"TypeScript doesn't handle the mapping of unions very well, so we need to ",Object(o.b)("inlineCode",{parentName:"p"},"as")," the ",Object(o.b)("inlineCode",{parentName:"p"},"choices"),"\nsetting. This isn't necessary when using a non-union.")),Object(o.b)("h3",{id:"arity-requirements"},"Arity requirements"),Object(o.b)("p",null,"Another scenario may require an exact number of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#multiple-values"}),"option values"),", otherwise an\nerror is thrown. This feature is known as arity (like function argument arity), and can be enabled\nwith the ",Object(o.b)("inlineCode",{parentName:"p"},"arity")," + ",Object(o.b)("inlineCode",{parentName:"p"},"multiple")," settings."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const argv = ['--colors', 'red', 'blue', 'green'];\nconst args = parse<{ colors: string[] }>(argv, {\n  options: {\n    colors: {\n      arity: 3,\n      description: 'Pick 3 favorite colors',\n      multiple: true,\n      type: 'string',\n    },\n  },\n});\n\nargs.options.colors; // ['red', 'blue', 'green']\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Arity will not error when 0 values are passed. To control this logic, use the ",Object(o.b)("inlineCode",{parentName:"p"},"validate")," setting.")),Object(o.b)("h3",{id:"command--option-categories"},"Command & option categories"),Object(o.b)("p",null,"While purely an informational feature, as it doesn't pertain to the parser, both commands and\noptions can be define a category. This category can be used within a consumer to group and organize\nbased on the category name."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const args = parse<{ color: string }>(argv, {\n  options: {\n    color: {\n      category: 'style',\n      description: 'Your favorite color',\n      type: 'string',\n    },\n  },\n});\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Command categories only pertain to the ",Object(o.b)("inlineCode",{parentName:"p"},"Command")," interface type.")),Object(o.b)("h2",{id:"type-casting"},"Type casting"),Object(o.b)("p",null,"While option and param values are configured as ",Object(o.b)("inlineCode",{parentName:"p"},"boolean"),", ",Object(o.b)("inlineCode",{parentName:"p"},"number"),", or ",Object(o.b)("inlineCode",{parentName:"p"},"string")," types, arguments\npassed on the command line are always strings. Because of this, the parser will type cast all\ncaptured values before returning the final result, as a means for easier interoperability."),Object(o.b)("p",null,"This type casting follows specific semantics (below) and may have side-effects depending on the\ninput provided."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"When a ",Object(o.b)("inlineCode",{parentName:"li"},"boolean"),", the following strings will be cast to ",Object(o.b)("inlineCode",{parentName:"li"},"true"),": true, on, yes, 1. The inverse will\nbe cast to ",Object(o.b)("inlineCode",{parentName:"li"},"false"),": false, off, no, 0. Other unsupported strings will also be cast to ",Object(o.b)("inlineCode",{parentName:"li"},"false"),"."),Object(o.b)("li",{parentName:"ul"},"When a ",Object(o.b)("inlineCode",{parentName:"li"},"number"),", the string will be cast using ",Object(o.b)("inlineCode",{parentName:"li"},"Number()"),". If a NaN occurs, the number will return\na ",Object(o.b)("inlineCode",{parentName:"li"},"0")," (use the ",Object(o.b)("inlineCode",{parentName:"li"},"validate")," setting for more control)."),Object(o.b)("li",{parentName:"ul"},"Strings are used as-is. Values with spaces or special characters should be wrapped in double\nquotes.")),Object(o.b)("h2",{id:"validation-checks"},"Validation checks"),Object(o.b)("p",null,"For improved interoperability and usability, the parser is strict, logging the following parse and\nvalidation errors."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"ParseError"),"s are logged for invalid syntax, unknown options, and formatting. The failed argument\nand its index are stored as ",Object(o.b)("inlineCode",{parentName:"li"},"arg")," and ",Object(o.b)("inlineCode",{parentName:"li"},"index")," properties on the error instance, respectively."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"ValidationError"),"s are logged for invalid values, types, settings, and more. The invalid option\n(when applicable), is stored as the ",Object(o.b)("inlineCode",{parentName:"li"},"option")," property.")),Object(o.b)("p",null,"Furthermore, errors are not thrown and instead are returned as an array in the ",Object(o.b)("inlineCode",{parentName:"p"},"parse()")," result,\nunder the ",Object(o.b)("inlineCode",{parentName:"p"},"errors")," property. It's designed this way so that command line interfaces and or\napplications have full control, and can theoretically provide output like the following."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'An error has occurred:\n\n  foo_bar --progressive --interactive -Y\n  \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n     \u2514\u2500 Invalid "foo_bar" command format. Must be letters, numbers, and dashes.\n\n')),Object(o.b)("h2",{id:"formatting-args"},"Formatting args"),Object(o.b)("p",null,"If for some reason you need to format the args result from ",Object(o.b)("inlineCode",{parentName:"p"},"parse()")," back into an array of string\narguments, the ",Object(o.b)("inlineCode",{parentName:"p"},"format()")," function can be used. This function will use the values as is and does not\nreference the settings object, so all formatted arguments will be in their long form, and will not\nuse inline values."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { format } from '@boost/args';\n\n// cmd --string abc --numbers 123 456 --bool foo bar baz -- qux --version\nconst argv = format({\n  command: ['cmd'],\n  options: { string: 'abc', numbers: [123, 456], bool: true },\n  params: ['foo', 'bar', 'baz'],\n  rest: ['qux', '--version'],\n});\n")))}d.isMDXComponent=!0},85:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return m}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),p=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},b=function(e){var n=p(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},d=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(t),d=a,m=b["".concat(i,".").concat(d)]||b[d]||u[d]||o;return t?r.a.createElement(m,s(s({ref:n},c),{},{components:t})):r.a.createElement(m,s({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},86:function(e,n,t){"use strict";function a(e){var n,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=a(e[n]))&&(r&&(r+=" "),r+=t);else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}n.a=function(){for(var e,n,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(n=a(e))&&(r&&(r+=" "),r+=n);return r}},87:function(e,n,t){"use strict";var a=t(0);const r=Object(a.createContext)(void 0);n.a=r},88:function(e,n,t){"use strict";var a=t(0),r=t(87);n.a=function(){const e=Object(a.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},89:function(e,n,t){"use strict";t.d(n,"a",(function(){return o}));var a=t(0),r=t.n(a);function o({children:e,type:n}){return r.a.createElement("span",{className:"badge badge--"+n},e)}},90:function(e,n,t){"use strict";var a=t(0),r=t.n(a),o=t(88),i=t(86),s=t(48),l=t.n(s);const c=37,p=39;n.a=function(e){const{block:n,children:t,defaultValue:s,values:b,groupId:u}=e,{tabGroupChoices:d,setTabGroupChoices:m}=Object(o.a)(),[h,g]=Object(a.useState)(s),[O,j]=Object(a.useState)(!1);if(null!=u){const e=d[u];null!=e&&e!==h&&b.some(n=>n.value===e)&&g(e)}const f=e=>{g(e),null!=u&&m(u,e)},v=[],N=e=>{e.metaKey||e.altKey||e.ctrlKey||j(!0)},y=()=>{j(!1)};return Object(a.useEffect)(()=>{window.addEventListener("keydown",N),window.addEventListener("mousedown",y)},[]),r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(i.a)("tabs",{"tabs--block":n})},b.map(({value:e,label:n})=>r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":h===e,className:Object(i.a)("tabs__item",l.a.tabItem,{"tabs__item--active":h===e}),style:O?{}:{outline:"none"},key:e,ref:e=>v.push(e),onKeyDown:e=>{((e,n,t)=>{switch(t.keyCode){case p:((e,n)=>{const t=e.indexOf(n)+1;e[t]?e[t].focus():e[0].focus()})(e,n);break;case c:((e,n)=>{const t=e.indexOf(n)-1;e[t]?e[t].focus():e[e.length-1].focus()})(e,n)}})(v,e.target,e),N(e)},onFocus:()=>f(e),onClick:()=>{f(e),j(!1)},onPointerDown:()=>j(!1)},n))),r.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},a.Children.toArray(t).filter(e=>e.props.value===h)[0]))}},91:function(e,n,t){"use strict";var a=t(0),r=t.n(a);n.a=function(e){return r.a.createElement("div",null,e.children)}},92:function(e,n,t){"use strict";t.d(n,"a",(function(){return c}));var a=t(0),r=t.n(a),o=t(89),i=t(47),s=t.n(i);function l({children:e}){return r.a.createElement("span",{className:s.a.badgeGroup},e)}function c({backend:e,frontend:n,tooling:t}){return r.a.createElement(l,null,e&&r.a.createElement(o.a,{type:"warning"},"Backend"),n&&r.a.createElement(o.a,{type:"success"},"Frontend"),t&&r.a.createElement(o.a,{type:"primary"},"Tooling"))}}}]);