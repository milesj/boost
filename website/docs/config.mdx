---
title: Configuration
---

import EnvBadges from '@theme/EnvBadges';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<EnvBadges backend tooling />

Powerful convention based finder, loader, and manager of both configuration and ignore files.

## Installation

<Tabs
  groupId="package-manager"
  defaultValue="yarn"
  values={[
    { label: 'Yarn', value: 'yarn' },
    { label: 'NPM', value: 'npm' },
  ]}
>
  <TabItem value="yarn">

```bash
yarn add @boost/config
```

  </TabItem>
  <TabItem value="npm">

```bash
npm install @boost/config
```

  </TabItem>
</Tabs>

## Events

| Event                             | Arguments         | Description                                                                                        |
| --------------------------------- | ----------------- | -------------------------------------------------------------------------------------------------- |
| `Configuration#onLoadedConfig`    | `ConfigFile<T>[]` | Waterfall: Called after config files are loaded but before processed. Can modify config file list. |
| `Configuration#onLoadedIgnore`    | `IgnoreFile[]`    | Waterfall: Called after ignore files are loaded. Can modify ignore file list.                      |
| `Configuration#onProcessedConfig` | `T`               | Called after config files are loaded and processed.                                                |

## Configuration

Configuration in the context of this package encompasses 2 concepts: config files and ignore files.
Config files are a collection of settings (key-value pairs), while ignore files are a list of file
path patterns and globs.

To utilize this functionality, we must extend the `Configuration` class, and define a blueprint for
the structure of our config file (using [optimal](./common/contract.md)). This class will fulfill
multiple roles: managing, finding, loading, and processing of files.

```ts
import { Blueprint, Predicates } from '@boost/common';
import { Configuration } from '@boost/config';

interface ConfigFile {
  ast?: boolean;
  cwd?: string;
  debug?: boolean;
  exclude?: string[];
  include?: string[];
}

class Manager extends Configuration<ConfigFile> {
  blueprint({ array, bool, string }: Predicates): Blueprint<ConfigFile> {
    return {
      ast: bool(),
      cwd: string(process.cwd()),
      debug: bool(),
      exclude: array(string()),
      include: array(string()),
    };
  }
}
```

This class layer is designed to be "internal only", and should not be utilized by consumers
directly. Instead, consumers should interact with an instance of the class, like so.

```ts
export default new Manager('boost');
```

> The string value passed to the constructor is the name of the config and ignore files, in camel
> case format. For example, `boost.js` and `.boostignore`.

### Finder options

To customize the config file finding and loading layer, call `Configuration#configureFinder()`
within bootstrap.

```ts
class Manager extends Configuration<ConfigFile> {
  // ...

  bootstrap() {
    this.configureFinder({
      extendsSetting: 'extends',
      includeEnv: false,
    });
  }
}
```

- `extendsSetting` (`string`) - Name of the setting in which [config extending](#extending-configs)
  is enabled.
- `extensions` (`ExtType[]`) - List of extensions, in order, to find config files. Defaults to js,
  json, cjs, mjs, yaml, yml.
- `includeEnv` (`boolean`) - Find and load environment based config files (using `NODE_ENV`).
  Defaults to `true`.
- `loaders` (`{ [K in LoaderType]: Loader<T> }`) - Mapping of loader functions by type. Defaults to
  normal file type loaders.
- `overridesSetting` (`string`) - Name of the setting in which
  [config overriding](#configs-overrides) is enabled.

### Processor options

To customize the config processing layer, call `Configuration#configureProcessor()` while within
bootstrap.

```ts
class Manager extends Configuration<ConfigFile> {
  // ...

  bootstrap() {
    this.configureProcessor({
      defaultWhenUndefined: false,
    });
  }
}
```

- `defaultWhenUndefined` (`boolean`) - When a setting has a value of `undefined`, fallback to the
  default/initial value for that setting. Defaults to `true`.
- `validate` (`boolean`) - Validate all settings within a config file before processing. Defaults to
  `true`.

### Processing settings

## Config files

### File patterns

### Loader types

### Loading config files

#### By environment

### Extending configs

#### Presets

### Config overrides

## Ignore files

An ignore file is a standard text file that denotes files and folders to ignore
(filter/exclude/etc), within the current directory, using matching globs and patterns.

### File patterns

Both root and branch level ignore files use the same file naming scheme. The file is prefixed with a
leading dot (`.`), followed by the name passed to your `Configuration` instance (in camel case), and
suffixed with `ignore`.

| Root            | Branch          |
| --------------- | --------------- |
| `.<name>ignore` | `.<name>ignore` |

> The root ignore file is not located within the `.config` folder as ignore paths/patterns/globs
> must be relative to the current directory.

### Loading ignore files

Ignore files can be found and loaded with either the `Configuration#loadIgnoreFromRoot()` or
`Configuration#loadIgnoreFromBranchToRoot()` methods -- both of which return a list of ignore
metadata. To demonstrate this, let's assume the following file system.

```
root/
├── modules/
│   ├── features/
│   │   ├── index.ts
│   │   └── .boostignore
│   ├── foo.ts
│   ├── bar.ts
│   └── baz.ts
└── .boostignore
```

```bash title="root/modules/features/.boostignore"
build/
```

```bash title="root/.boostignore"
*.log
*.lock
```

The `Configuration#loadIgnoreFromRoot()` will load the ignore file found in the root folder
(typically 1 file). If no root path is provided, it defaults to `process.cwd()`.

```ts
const list = manager.loadIgnoreFromRoot('/root');

/*
[
  {
    ignore: ['*.log', '*.lock'],
    path: new Path('/root'),
    source: 'root',
  },
]
*/
```

The `loadIgnoreFromBranchToRoot()` method will load an ignore file from each folder while traversing
upwards from the branch folder to the root folder. The found list is returned in reverse order so
that the deepest branch can be used to overwrite the previous branch (or root).

```ts
const list = manager.loadIgnoreFromBranchToRoot('/root/modules/features');

/*
[
  {
    ignore: ['*.log', '*.lock'],
    path: new Path('/root'),
    source: 'root',
  },
  {
    ignore: ['build/'],
    path: new Path('/root/modules/features'),
    source: 'branch',
  },
]
*/
```
