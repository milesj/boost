---
title: Configuration
---

import EnvBadges from '@theme/EnvBadges';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<EnvBadges backend tooling />

Powerful convention based finder, loader, and manager of both configuration and ignore files.

## Installation

<Tabs
  groupId="package-manager"
  defaultValue="yarn"
  values={[
    { label: 'Yarn', value: 'yarn' },
    { label: 'NPM', value: 'npm' },
  ]}
>
  <TabItem value="yarn">

```bash
yarn add @boost/config
```

  </TabItem>
  <TabItem value="npm">

```bash
npm install @boost/config
```

  </TabItem>
</Tabs>

## Events

| Event                             | Arguments         | Description                                                                                        |
| --------------------------------- | ----------------- | -------------------------------------------------------------------------------------------------- |
| `Configuration#onLoadedConfig`    | `ConfigFile<T>[]` | Waterfall: Called after config files are loaded but before processed. Can modify config file list. |
| `Configuration#onLoadedIgnore`    | `IgnoreFile[]`    | Waterfall: Called after ignore files are loaded. Can modify ignore file list.                      |
| `Configuration#onProcessedConfig` | `T`               | Called after config files are loaded and processed.                                                |

## Configuration

Configuration in the context of this package encompasses 2 concepts: config files and ignore files.
Config files are a collection of settings (key-value pairs), while ignore files are a list of file
path patterns and globs.

To utilize this functionality, we must extend the `Configuration` class, and define a blueprint for
the structure of our config file (using [optimal](./common/contract.md)). This class will fulfill
multiple roles: managing, finding, loading, and processing of files.

```ts
import { Blueprint, Predicates } from '@boost/common';
import { Configuration } from '@boost/config';

// Example structure
interface ConfigFile {
  ast?: boolean;
  cwd?: string;
  debug?: boolean;
  exclude?: string[];
  include?: string[];
  options?: object;
}

class Manager extends Configuration<ConfigFile> {
  blueprint({ array, bool, string, object }: Predicates): Blueprint<ConfigFile> {
    return {
      ast: bool(),
      cwd: string(process.cwd()),
      debug: bool(),
      exclude: array(string()),
      include: array(string()),
      options: object(),
    };
  }
}
```

This class layer is designed to be "internal only", and should not be utilized by consumers
directly. Instead, consumers should interact with an instance of the class, like so.

```ts
export default new Manager('boost');
```

> The string value passed to the constructor is the name of the config and ignore files, in camel
> case format. For example, `boost.js` and `.boostignore`.

### Finder options

To customize the config file finding and loading layer, call `Configuration#configureFinder()`
within bootstrap.

```ts
class Manager extends Configuration<ConfigFile> {
  // ...

  bootstrap() {
    this.configureFinder({
      extendsSetting: 'extends',
      includeEnv: false,
    });
  }
}
```

- `extendsSetting` (`string`) - Name of the setting in which [config extending](#extending-configs)
  is enabled.
- `extensions` (`ExtType[]`) - List of extensions, in order, to find config files. Defaults to js,
  json, cjs, mjs, ts, yaml, yml.
- `includeEnv` (`boolean`) - Find and load environment based config files (using `NODE_ENV`).
  Defaults to `true`.
- `loaders` (`{ [K in LoaderType]: Loader<T> }`) - Mapping of loader functions by type. Defaults to
  normal file type loaders.
- `overridesSetting` (`string`) - Name of the setting in which
  [config overriding](#configs-overrides) is enabled.

### Processor options

To customize the config processing layer, call `Configuration#configureProcessor()` while within
bootstrap.

```ts
class Manager extends Configuration<ConfigFile> {
  // ...

  bootstrap() {
    this.configureProcessor({
      defaultWhenUndefined: false,
    });
  }
}
```

- `defaultWhenUndefined` (`boolean`) - When a setting has a value of `undefined`, fallback to the
  default/initial value for that setting. Defaults to `true`.
- `validate` (`boolean`) - Validate all settings within a config file before processing. Defaults to
  `true`.

### Processing settings

When multiple config files are merged into a single config file, this is known as processing.
Processing happens automatically for each setting as we need to determine what the next setting
value would be. By default, the following rules apply when the next and previous setting values are:

- _Arrays_: will be merged and deduped into a new array.
- _Objects_: will be shallow merged (using spread) into a new object.
- _Primitives_: next value will overwrite the previous value.
- _Undefined_: will reset to initial value if `defaultWhenUndefined` is true.

If you would like to customize this process, you can define custom process handlers per setting with
`Configuration#addProcessHandler()`. This method requires a setting name and handler function (which
is passed the previous and next values).

```ts
class Manager extends Configuration<ConfigFile> {
  // ...

  bootstrap() {
    // Always use forward slashes
    this.addProcessHandler('cwd', (prev, next) => next.replace(/\\/g, '/'));

    // Deep merge options since they're dynamic
    this.addProcessHandler('options', (prev, next) => deepMerge(prev, next));
  }
}
```

> Handlers may only be defined on root-level settings.

To make this process even easier, we provide a handful of pre-defined handlers (below) that can be
used for common scenarios (these handlers power the default rules mentioned above).

- `mergeArray` - Merges previous and next arrays into a new array while removing duplicates (using
  `Set`).
- `mergeExtends` - Merges previous and next file paths (either a string or array of strings) into a
  new list of file paths. This is useful if utilizing [config extending](#extending-configs).
- `mergeObject` - Shallow merges previous and next objects into a new object using object spread.
- `mergePlugins` - Merges previous and next plugin configurations into an object. Plugin configs can
  either be a list of module names, or a map of module names to flags/options. This is useful if
  utilizing the [plugin package](./plugin.mdx#configuration-files).
- `overwrite` - Overwrite the previous value with the next value.

```ts
import { mergePlugins } from '@boost/config';

class Manager extends Configuration<ConfigFile> {
  // ...

  bootstrap() {
    // Using example from plugins documentation
    this.addProcessHandler('renderers', mergePlugins);
  }
}
```

## Config files

### File patterns

### Loader types

### Loading config files

#### By environment

### Extending configs

#### Presets

### Config overrides

## Ignore files

An ignore file is a standard text file that denotes files and folders to ignore
(filter/exclude/etc), within the current directory, using matching globs and patterns.

### File patterns

Both root and branch level ignore files use the same file naming scheme. The file is prefixed with a
leading dot (`.`), followed by the name passed to your `Configuration` instance (in camel case), and
suffixed with `ignore`.

| Root            | Branch          |
| --------------- | --------------- |
| `.<name>ignore` | `.<name>ignore` |

> The root ignore file is not located within the `.config` folder as ignore paths/patterns/globs
> must be relative to the current directory.

### Loading ignore files

Ignore files can be found and loaded with either the `Configuration#loadIgnoreFromRoot()` or
`Configuration#loadIgnoreFromBranchToRoot()` methods -- both of which return a list of ignore
metadata. To demonstrate this, let's assume the following file system.

```
root/
├── modules/
│   ├── features/
│   │   ├── index.ts
│   │   └── .boostignore
│   ├── foo.ts
│   ├── bar.ts
│   └── baz.ts
└── .boostignore
```

```bash title="root/modules/features/.boostignore"
build/
```

```bash title="root/.boostignore"
*.log
*.lock
```

The `Configuration#loadIgnoreFromRoot()` will load the ignore file found in the root folder
(typically 1 file). If no root path is provided, it defaults to `process.cwd()`.

```ts
const list = manager.loadIgnoreFromRoot('/root');

/*
[
  {
    ignore: ['*.log', '*.lock'],
    path: new Path('/root'),
    source: 'root',
  },
]
*/
```

The `loadIgnoreFromBranchToRoot()` method will load an ignore file from each folder while traversing
upwards from the branch folder to the root folder. The found list is returned in reverse order so
that the deepest branch can be used to overwrite the previous branch (or root).

```ts
const list = manager.loadIgnoreFromBranchToRoot('/root/modules/features');

/*
[
  {
    ignore: ['*.log', '*.lock'],
    path: new Path('/root'),
    source: 'root',
  },
  {
    ignore: ['build/'],
    path: new Path('/root/modules/features'),
    source: 'branch',
  },
]
*/
```
