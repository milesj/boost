"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3466],{5318:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var a=t(7378);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=s(t),m=i,h=d["".concat(p,".").concat(m)]||d[m]||c[m]||r;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=d;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9798:function(e,n,t){t.d(n,{Z:function(){return l}});var a=t(7378),i=t(8944),r="tabItem_wHwb";function l(e){var n=e.children,t=e.hidden,l=e.className;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,l),hidden:t},n)}},3337:function(e,n,t){t.d(n,{Z:function(){return h}});var a=t(5773),i=t(7378),r=t(8944),l=t(3457),o=t(5595),p=t(6457),s="tabList_J5MA",u="tabItem_l0OV";function c(e){var n=e.className,t=e.block,o=e.selectedValue,p=e.selectValue,s=e.tabValues,c=[],d=(0,l.o5)().blockElementScrollPositionUntilNextRender,m=function(e){var n=e.currentTarget,t=c.indexOf(n),a=s[t].value;a!==o&&(d(n),p(a))},h=function(e){var n,t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":var a,i=c.indexOf(e.currentTarget)+1;t=null!=(a=c[i])?a:c[0];break;case"ArrowLeft":var r,l=c.indexOf(e.currentTarget)-1;t=null!=(r=c[l])?r:c[c.length-1]}null==(n=t)||n.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},n)},s.map((function(e){var n=e.value,t=e.label,l=e.attributes;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:function(e){return c.push(e)},onKeyDown:h,onClick:m},l,{className:(0,r.Z)("tabs__item",u,null==l?void 0:l.className,{"tabs__item--active":o===n})}),null!=t?t:n)})))}function d(e){var n=e.lazy,t=e.children,a=e.selectedValue,r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){var l=r.find((function(e){return e.props.value===a}));return l?(0,i.cloneElement)(l,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},r.map((function(e,n){return(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a})})))}function m(e){var n=(0,o.Y)(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",s)},i.createElement(c,(0,a.Z)({},e,n)),i.createElement(d,(0,a.Z)({},e,n)))}function h(e){var n=(0,p.Z)();return i.createElement(m,(0,a.Z)({key:String(n)},e))}},5595:function(e,n,t){t.d(n,{Y:function(){return d}});var a=t(7378),i=t(5331),r=t(654),l=t(784),o=t(1819);function p(e){return function(e){var n,t;return null!=(n=null==(t=a.Children.map(e,(function(e){if(!e||(0,a.isValidElement)(e)&&(n=e.props)&&"object"==typeof n&&"value"in n)return e;var n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}(e).map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}}))}function s(e){var n=e.values,t=e.children;return(0,a.useMemo)((function(){var e=null!=n?n:p(t);return function(e){var n=(0,l.l)(e,(function(e,n){return e.value===n.value}));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function u(e){var n=e.value;return e.tabValues.some((function(e){return e.value===n}))}function c(e){var n=e.queryString,t=void 0!==n&&n,l=e.groupId,o=(0,i.k6)(),p=function(e){var n=e.queryString,t=void 0!==n&&n,a=e.groupId;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:t,groupId:l});return[(0,r._X)(p),(0,a.useCallback)((function(e){if(p){var n=new URLSearchParams(o.location.search);n.set(p,e),o.replace(Object.assign({},o.location,{search:n.toString()}))}}),[p,o])]}function d(e){var n,t,i,r,l=e.defaultValue,p=e.queryString,d=void 0!==p&&p,m=e.groupId,h=s(e),f=(0,a.useState)((function(){return function(e){var n,t=e.defaultValue,a=e.tabValues;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!u({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}var i=null!=(n=a.find((function(e){return e.default})))?n:a[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:l,tabValues:h})})),k=f[0],g=f[1],v=c({queryString:d,groupId:m}),b=v[0],w=v[1],y=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:m}.groupId),t=(0,o.Nk)(n),i=t[0],r=t[1],[i,(0,a.useCallback)((function(e){n&&r.set(e)}),[n,r])]),N=y[0],x=y[1],C=function(){var e=null!=b?b:N;return u({value:e,tabValues:h})?e:null}();return(0,a.useLayoutEffect)((function(){C&&g(C)}),[C]),{selectedValue:k,selectValue:(0,a.useCallback)((function(e){if(!u({value:e,tabValues:h}))throw new Error("Can't select invalid tab value="+e);g(e),w(e),x(e)}),[w,x,h]),tabValues:h}}},297:function(e,n,t){t.d(n,{Z:function(){return i}});var a=t(7378);function i(e){var n=e.children,t=e.type;return a.createElement("span",{className:"badge badge--"+t},n)}},2723:function(e,n,t){t.d(n,{Z:function(){return u}});var a=t(7378),i=t(1884),r=t(6125),l=t(297),o="badgeGroup_syf7",p="apiLink_JWAN";function s(e){var n=e.children;return a.createElement("span",{className:o},n)}function u(e){var n=e.api,t=e.backend,o=e.frontend,u=e.tooling;return a.createElement(a.Fragment,null,n&&a.createElement(i.default,{className:p,to:n},"API ",a.createElement(r.Z,null)),a.createElement(s,null,t&&a.createElement(l.Z,{type:"warning"},"Backend"),o&&a.createElement(l.Z,{type:"success"},"Frontend"),u&&a.createElement(l.Z,{type:"primary"},"Tooling")))}},2149:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return c},default:function(){return k},frontMatter:function(){return u},metadata:function(){return d},toc:function(){return h}});var a=t(5773),i=t(808),r=(t(7378),t(5318)),l=t(2723),o=t(3337),p=t(9798),s=["components"],u={title:"Pipelines"},c=void 0,d={unversionedId:"pipeline",id:"pipeline",title:"Pipelines",description:"Pipe an input through a series of type-safe routines and tasks to produce an output, or simply, run",source:"@site/docs/pipeline.mdx",sourceDirName:".",slug:"/pipeline",permalink:"/docs/pipeline",draft:!1,editUrl:"https://github.com/milesj/boost/edit/master/website/docs/pipeline.mdx",tags:[],version:"current",frontMatter:{title:"Pipelines"},sidebar:"docs",previous:{title:"Modules",permalink:"/docs/module"},next:{title:"Plugins",permalink:"/docs/plugin"}},m={},h=[{value:"Installation",id:"installation",level:2},{value:"Pipelines",id:"pipelines",level:2},{value:"Contexts",id:"contexts",level:3},{value:"Input &amp; output types",id:"input--output-types",level:3},{value:"Work types",id:"work-types",level:2},{value:"Task",id:"task",level:3},{value:"Routine",id:"routine",level:3},{value:"Creating hierarchical pipelines",id:"creating-hierarchical-pipelines",level:4},{value:"Executing local binaries",id:"executing-local-binaries",level:4},{value:"Pipeline types",id:"pipeline-types",level:2},{value:"<em>Parallel</em>",id:"parallel",level:3},{value:"ConcurrentPipeline",id:"concurrentpipeline",level:3},{value:"AggregatedPipeline",id:"aggregatedpipeline",level:3},{value:"PooledPipeline",id:"pooledpipeline",level:3},{value:"<em>Serial</em>",id:"serial",level:3},{value:"WaterfallPipeline",id:"waterfallpipeline",level:3},{value:"Caveats",id:"caveats",level:2},{value:"Conditional serial pipelines",id:"conditional-serial-pipelines",level:3}],f={toc:h};function k(e){var n=e.components,t=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)(l.Z,{backend:!0,tooling:!0,api:"/api/pipeline",mdxType:"EnvBadges"}),(0,r.kt)("p",null,"Pipe an input through a series of type-safe routines and tasks to produce an output, or simply, run\nlogic in a series of stages."),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)(o.Z,{groupId:"package-manager",defaultValue:"yarn",values:[{label:"Yarn",value:"yarn"},{label:"npm",value:"npm"}],mdxType:"Tabs"},(0,r.kt)(p.Z,{value:"yarn",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add @boost/pipeline\n"))),(0,r.kt)(p.Z,{value:"npm",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @boost/pipeline\n")))),(0,r.kt)("h2",{id:"pipelines"},"Pipelines"),(0,r.kt)("p",null,"A pipeline can be used to process an input, either in parallel or serial, through a series of\nactions known as work units, to produce an output. If you don't need an input, but merely need to\nprocess work in stages, the pipeline supports that as well. There are multiple types of\n",(0,r.kt)("a",{parentName:"p",href:"#work-types"},"work units")," and ",(0,r.kt)("a",{parentName:"p",href:"#pipeline-types"},"pipelines"),", so choose the best one for each use\ncase."),(0,r.kt)("p",null,"To begin, instantiate a pipeline with a ",(0,r.kt)("a",{parentName:"p",href:"#contexts"},"context"),", and an ",(0,r.kt)("em",{parentName:"p"},"optional")," input value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context, ConcurrentPipeline } from '@boost/pipeline';\nimport { referenceFunction } from './example';\n\nconst input = 123;\nconst pipeline = new ConcurrentPipeline(new Context(), input);\n")),(0,r.kt)("p",null,"Once instantiated, we must register work units (either a ",(0,r.kt)("a",{parentName:"p",href:"#task"},"task")," or ",(0,r.kt)("a",{parentName:"p",href:"#routine"},"routine"),") that\nwill process the input value, either with\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/ParallelPipeline#add"},(0,r.kt)("inlineCode",{parentName:"a"},"ParallelPipeline#add()"))," or\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/SerialPipeline#pipe"},(0,r.kt)("inlineCode",{parentName:"a"},"SerialPipeline#pipe()")),". All work units require a\ndescriptive title, and are passed the context and current value when being executed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Tasks\npipeline.add('Task using an anonymous function', (context, value) => value);\npipeline.add('Task using a function reference', referenceFunction);\npipeline.add(new Task('Task using a class instance', referenceFunction));\n\n// Routines\npipeline.add(new ExampleRoutine('key', 'Explicit routine using a class instance'));\n")),(0,r.kt)("p",null,"And to finish, we can execute our pipeline to process each work unit and produce the final output\nvalue."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const output = await pipeline.run();\n")),(0,r.kt)("h3",{id:"contexts"},"Contexts"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Context"},(0,r.kt)("inlineCode",{parentName:"a"},"Context"))," is merely a plain class that provides contextual\ninformation to all work units, and is passed as the 1st argument when executing. It's highly\nencouraged to create custom contexts with typed properties, helper methods, and more."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context } from '@boost/pipeline';\n\nexport default class ProcessContext extends Context {\n  readonly cwd: string;\n\n  readonly root: string;\n\n  constructor(root: string, cwd?: string) {\n    this.cwd = cwd || process.cwd();\n    this.root = root;\n  }\n}\n")),(0,r.kt)("p",null,"A unique feature of contexts is the ability to deep clone itself using\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Context#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"Context#clone()")),". This method is extremely useful when a\ncontext of the same shape must be passed to another pipeline without collisions or mutations\noccurring."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const newContext = context.clone();\n")),(0,r.kt)("h3",{id:"input--output-types"},"Input & output types"),(0,r.kt)("p",null,"The input type is inferred from the 2nd constructor argument, while the output type defaults to the\ninput type. If you need to customize either the input or output type manually, the pipeline generics\ncan be customized upon instantiation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const pipeline = new ConcurrentPipeline<Context, number, string[]>(new Context(), 123);\n")),(0,r.kt)("h2",{id:"work-types"},"Work types"),(0,r.kt)("p",null,"There are 2 types of work units that can be registered in a pipeline."),(0,r.kt)("h3",{id:"task"},"Task"),(0,r.kt)("p",null,"A task is simply a function/method (in any form) that accepts an input and returns an output. It can\nbe represented by a standard function or a ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Task"},(0,r.kt)("inlineCode",{parentName:"a"},"Task"))," instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context } from '@boost/pipeline';\n\nfunction task(context: Context, value: number): string {\n  return value.toLocaleString();\n}\n\nparallelPipeline.add('A title for this task', task);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context, Task } from '@boost/pipeline';\n\nconst task = new Task('A title for this task', (context: Context, value: number) =>\n  value.toLocaleString(),\n);\n\nserialPipeline.pipe(task);\n")),(0,r.kt)("h3",{id:"routine"},"Routine"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine"))," is a specialized work unit implemented with a class. It\nprovides helper methods, the ability to create nested hierarchical pipelines, and an implicit\nencapsulation of similar logic and tasks."),(0,r.kt)("p",null,"To begin, import and extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"Routine")," class and implement the\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#blueprint"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine#blueprint()"))," and\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#execute"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine#execute()"))," methods. The class requires 3 generics to\nbe defined, starting with an output type (defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),"), an input type (defaults to\n",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),"), and an options interface (defaults to an empty object)."),(0,r.kt)("p",null,"The blueprint method is inherited from ",(0,r.kt)("a",{parentName:"p",href:"/docs/common#contract"},(0,r.kt)("inlineCode",{parentName:"a"},"Contract")),", and should return an\nobject that matches the structure of the generic options interface. The execute method should accept\nthe input type and return the expected output type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Blueprint, Schemas, Bind } from '@boost/common';\nimport { Routine } from '@boost/pipeline';\n\ninterface ExampleOptions {\n  limit?: number;\n}\n\ntype Input = number;\ntype Output = string;\n\nexport default class ExampleRoutine extends Routine<Output, Input, ExampleOptions> {\n  blueprint({ number }: Schemas): Blueprint<ExampleOptions> {\n    return {\n      limit: number(10),\n    };\n  }\n\n  async execute(context: Context, value: Input): Promise<Output> {\n    return this.createWaterfallPipeline(context, value)\n      .pipe('Rounding to cents', this.roundToCents)\n      .pipe('Converting to readable format', this.makeReadable)\n      .pipe('Adding currency', this.addCurrency)\n      .run();\n  }\n\n  @Bind\n  roundToCents(context: Context, value: number): number {\n    return Number(value.toFixed(2));\n  }\n\n  @Bind\n  makeReadable(context: Context, value: number): string {\n    return value.toLocaleString();\n  }\n\n  @Bind\n  addCurrency(context: Context, value: string): string {\n    return `$${value}`;\n  }\n}\n")),(0,r.kt)("p",null,"When instantiating a routine, a unique key and title must be provided, both of which are primarily\nused for streaming to a console. An options object can be passed as the 3rd argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"new ExampleRoutine('key', 'Custom title here', { limit: 5 });\n")),(0,r.kt)("h4",{id:"creating-hierarchical-pipelines"},"Creating hierarchical pipelines"),(0,r.kt)("p",null,"The most prominent feature of ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine"))," is the ability to create\nhierarchical pipelines that can be nested or executed in any fashion. This can be achieved with the\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#createAggregatedPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine#createAggregatedPipeline()")),",\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#createConcurrentPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"#createConcurrentPipeline()")),",\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#createPooledPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"#createPooledPipeline()")),", and\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#createWaterfallPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"#createWaterfallPipeline()"))," methods, all of\nwhich require a ",(0,r.kt)("a",{parentName:"p",href:"#contexts"},"context")," and an initial value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class ExampleRoutine extends Routine<Item[]> {\n  async execute(context: Context, items: Item[]): Promise<Item[]> {\n    return this.createConcurrentPipeline(context, [])\n      .add('Load items from cache', this.loadItemsFromCache)\n      .add('Fetch remote items', this.fetchItems)\n      .add('Sort and enqueue items', () => {\n        return this.createWaterfallPipeline(context, items)\n          .pipe(new SortRoutine('sort', 'Sorting items'))\n          .pipe(new QueueRoutine('queue', 'Enqueueing items'))\n          .run(),\n      })\n      .run();\n  }\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#depth"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine#depth"))," property denotes the current depth within\nthe hierarchy tree, while ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#index"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine#index"))," is the current index\namongst all work at the same depth."),(0,r.kt)("h4",{id:"executing-local-binaries"},"Executing local binaries"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/Routine#executeCommand"},(0,r.kt)("inlineCode",{parentName:"a"},"Routine#executeCommand()"))," method can be used to\nexecute binaries and commands on the host machine (it uses\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/sindresorhus/execa"},"execa")," under the hood). This is extremely useful for\nexecuting locally installed npm/Yarn binaries."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class ExampleRoutine extends Routine<string> {\n  async execute(context: Context): Promise<string> {\n    return this.executeCommand('babel', ['./src', '--out-dir', './lib'], {\n      preferLocal: true,\n    }).then((result) => result.stdout);\n  }\n}\n")),(0,r.kt)("h2",{id:"pipeline-types"},"Pipeline types"),(0,r.kt)("p",null,"There are 4 types of pipelines, grouped into parallel and serial based patterns."),(0,r.kt)("h3",{id:"parallel"},(0,r.kt)("em",{parentName:"h3"},"Parallel")),(0,r.kt)("p",null,"Parallel pipelines register work units with\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/ParallelPipeline#add"},(0,r.kt)("inlineCode",{parentName:"a"},"ParallelPipeline#add()")),", and process the work units in\nparallel when executing ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/ParallelPipeline#run"},(0,r.kt)("inlineCode",{parentName:"a"},"ParallelPipeline#run()")),"."),(0,r.kt)("h3",{id:"concurrentpipeline"},"ConcurrentPipeline"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/ConcurrentPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"ConcurrentPipeline"))," executes all work units in\nparallel, and returns a list of values once all resolve. If an error occurs, the pipeline will be\ninterrupted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context, ConcurrentPipeline } from '@boost/pipeline';\n\nconst pipeline = new ConcurrentPipeline(new Context(), initialValue)\n  .add('First task', doSomething)\n  .add('Second task', anotherSomething)\n  .add('Final task', finalSomething);\n\nconst values = await pipeline.run();\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This pipeline will run ",(0,r.kt)("em",{parentName:"p"},"all")," work units at once. If there are far too many work units, it may\ndegrade performance. In that case, use ",(0,r.kt)("a",{parentName:"p",href:"#pooledpipeline"},"PooledPipeline")," instead.")),(0,r.kt)("h3",{id:"aggregatedpipeline"},"AggregatedPipeline"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/AggregatedPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"AggregatedPipeline"))," executes all work units in\nparallel ",(0,r.kt)("em",{parentName:"p"},"without")," interruption, and returns an object with a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"errors")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"results")," once\nall resolve."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context, AggregatedPipeline } from '@boost/pipeline';\n\nconst pipeline = new AggregatedPipeline(new Context(), initialValue)\n  .add('First task', doSomething)\n  .add('Second task', anotherSomething)\n  .add('Final task', finalSomething);\n\nconst { errors, results } = await pipeline.run();\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Like ",(0,r.kt)("inlineCode",{parentName:"p"},"ConcurrentPipeline"),", all work units are ran at once. For performance improvements, use\n",(0,r.kt)("a",{parentName:"p",href:"#pooledpipeline"},"PooledPipeline")," when dealing with a large number of work units.")),(0,r.kt)("h3",{id:"pooledpipeline"},"PooledPipeline"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/PooledPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"PooledPipeline"))," executes a distinct set of work units in\nparallel ",(0,r.kt)("em",{parentName:"p"},"without")," interruption, based on a max concurrency limit, until all work units have ran.\nReturns an object with a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"errors")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"results")," once all resolve."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context, PooledPipeline } from '@boost/pipeline';\n\nconst pipeline = new PooledPipeline(new Context(), initialValue)\n  .add('First task', doSomething)\n  .add('Second task', anotherSomething)\n  .add('Final task', finalSomething);\n\nconst { errors, results } = await pipeline.run();\n")),(0,r.kt)("p",null,"The pipeline supports an optional ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/interface/PooledOptions"},(0,r.kt)("inlineCode",{parentName:"a"},"PooledOptions"))," object as\nits 3rd argument."),(0,r.kt)("h3",{id:"serial"},(0,r.kt)("em",{parentName:"h3"},"Serial")),(0,r.kt)("p",null,"Serial pipelines register work units in a sequence with\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/SerialPipeline#pipe"},(0,r.kt)("inlineCode",{parentName:"a"},"SerialPipeline#pipe()")),", and process the work units one\nby one when executing ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/SerialPipeline#run"},(0,r.kt)("inlineCode",{parentName:"a"},"SerialPipeline#run()")),"."),(0,r.kt)("h3",{id:"waterfallpipeline"},"WaterfallPipeline"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/WaterfallPipeline"},(0,r.kt)("inlineCode",{parentName:"a"},"WaterfallPipeline"))," executes each work unit one by one,\nwith the return value of the previous work unit being passed as a value argument to the next work\nunit. Returns the final value once all resolve."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Context, WaterfallPipeline } from '@boost/pipeline';\n\nconst pipeline = new WaterfallPipeline(new Context(), 1000)\n  .pipe('Multiply initial value', (ctx, value) => value * 3)\n  .pipe('Convert to a readable string', (ctx, value) => value.toLocaleString())\n  .pipe('Convert to an array for reasons unknown', (ctx, value) => [value]);\n\nconst finalValue = await pipeline.run(); // ['3,000']\n")),(0,r.kt)("h2",{id:"caveats"},"Caveats"),(0,r.kt)("h3",{id:"conditional-serial-pipelines"},"Conditional serial pipelines"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#serial"},"Serial pipelines")," are designed using a linked list, with each call to\n",(0,r.kt)("a",{parentName:"p",href:"/api/pipeline/class/SerialPipeline#pipe"},(0,r.kt)("inlineCode",{parentName:"a"},"SerialPipeline#pipe()"))," returning a new instance. It was\ndesigned this way so that input and output types would cascade correctly down the chain. However,\nthis pattern causes issues where pipes are called within conditionals, resulting in new pipes to be\nlost. For example, this is ",(0,r.kt)("em",{parentName:"p"},"invalid"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const pipeline = new WaterfallPipeline(new Context());\n\nif (condition) {\n  pipeline.pipe('Do this', thisAction);\n} else {\n  pipeline.pipe('Do that', thatAction);\n}\n\nawait pipeline\n  .pipe('Then finish', finishAction)\n  .run();\n")),(0,r.kt)("p",null,"While this is technically valid (note the ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"pipeline")," assignment), but will break down if\ntypes conflict."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let pipeline = new WaterfallPipeline(new Context());\n\nif (condition) {\n  pipeline = pipeline.pipe('Do this', thisAction);\n} else {\n  pipeline = pipeline.pipe('Do that', thatAction);\n}\n\nawait pipeline\n  .pipe('Then finish', finishAction)\n  .run();\n")),(0,r.kt)("p",null,"Instead, it's suggested to use separate pipelines within each conditional block. This approach\nrequires a bit of duplication, but avoids all other issues."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"if (condition) {\n  await new WaterfallPipeline(new Context())\n    .pipe('Do this', thisAction)\n    .pipe('Then finish', finishAction)\n    .run()\n} else {\n  await new WaterfallPipeline(new Context())\n    .pipe('Do that', thatAction)\n    .pipe('Then finish', finishAction)\n    .run()\n}\n")))}k.isMDXComponent=!0}}]);