(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[660],{5318:function(e,t,o){"use strict";o.d(t,{Zo:function(){return u},kt:function(){return h}});var n=o(7378);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function l(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function a(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?l(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):l(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)o=l[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)o=l[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):a(a({},t),e)),o},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=p(o),h=r,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||l;return o?n.createElement(m,a(a({ref:t},u),{},{components:o})):n.createElement(m,a({ref:t},u))}));function h(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=o.length,a=new Array(l);a[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,a[1]=i;for(var p=2;p<l;p++)a[p]=o[p];return n.createElement.apply(null,a)}return n.createElement.apply(null,o)}d.displayName="MDXCreateElement"},1836:function(e,t,o){"use strict";o.r(t),o.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return u},default:function(){return d}});var n=o(9603),r=o(120),l=(o(7378),o(5318)),a=["components"],i={title:"PathResolver"},s=void 0,p={unversionedId:"common/path-resolver",id:"common/path-resolver",isDocsHomePage:!1,title:"PathResolver",description:"A PathResolver can be used to find a real path amongst a list of possible lookups. A lookup is",source:"@site/docs/common/path-resolver.md",sourceDirName:"common",slug:"/common/path-resolver",permalink:"/docs/common/path-resolver",editUrl:"https://github.com/milesj/boost/edit/master/website/docs/common/path-resolver.md",version:"current",frontMatter:{title:"PathResolver"},sidebar:"docs",previous:{title:"Path",permalink:"/docs/common/path"},next:{title:"Project",permalink:"/docs/common/project"}},u=[{value:"API",id:"api",children:[{value:"<code>getLookupPaths</code>",id:"getlookuppaths",children:[]},{value:"<code>lookupFilePath</code>",id:"lookupfilepath",children:[]},{value:"<code>lookupNodeModule</code>",id:"lookupnodemodule",children:[]},{value:"<code>resolve</code>",id:"resolve",children:[]},{value:"<code>resolvePath</code>",id:"resolvepath",children:[]}]}],c={toc:u};function d(e){var t=e.components,o=(0,r.Z)(e,a);return(0,l.kt)("wrapper",(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"PathResolver")," can be used to find a real path amongst a list of possible lookups. A lookup is\neither a file system path or a Node.js module. If a path is found, an absolute resolved\n",(0,l.kt)("a",{parentName:"p",href:"/docs/common/path"},(0,l.kt)("inlineCode",{parentName:"a"},"Path"))," instance is returned, otherwise an error is thrown."),(0,l.kt)("p",null,"A perfect scenario for this mechanism would be finding a valid configuration file, which we'll\ndemonstrate below. Import and instantiate the class to begin."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { PathResolver } from '@boost/common';\n\nconst resolver = new PathResolver();\n")),(0,l.kt)("p",null,"To add a file system lookup, use the ",(0,l.kt)("inlineCode",{parentName:"p"},"PathResolver#lookupFilePath()")," method, which requires a path\nand an optional current working directory (defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"process.cwd()"),")."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// Look in current directory\nresolver\n    .lookupFilePath('tool.config.js')\n    .lookupFilePath('tool.config.json')\n    .lookupFilePath('tool.config.yaml');\n\n// Look in a folder\nresolver.lookupFilePath('configs/tool.js');\n\n// Look in user's home directory\nresolver.lookupFilePath('tool.config.js', os.homedir());\n")),(0,l.kt)("p",null,"And to add a Node.js module lookup, use the ",(0,l.kt)("inlineCode",{parentName:"p"},"PathResolver#lookupNodeModule()")," method, which accepts\na module name or path."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// Look in module (assuming index export)\nresolver.lookupNodeModule('tool-config-module');\n\n// Look in module with sub-path\nresolver.lookupNodeModule('tool-config-module/lib/configs/tool.js');\n")),(0,l.kt)("p",null,"Once all the lookup paths have been defined, the ",(0,l.kt)("inlineCode",{parentName:"p"},"PathResolver#resolve()")," method will iterate\nthrough them in order until one is found. If a file system path, ",(0,l.kt)("inlineCode",{parentName:"p"},"fs.existsSync()")," will be used to\ncheck for existence, while ",(0,l.kt)("inlineCode",{parentName:"p"},"require.resolve()")," will be used for Node.js modules. If found, a result\nobject will be returned with the resolved ",(0,l.kt)("inlineCode",{parentName:"p"},"Path")," and original lookup parts."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const { originalPath, resolvedPath, type } = resolver.resolve();\n")),(0,l.kt)("p",null,"If you'd prefer to only have the resolved path returned, the ",(0,l.kt)("inlineCode",{parentName:"p"},"PathResolver#resolvePath()")," method can\nbe used instead."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const resolvedPath = resolver.resolvePath();\n")),(0,l.kt)("h2",{id:"api"},"API"),(0,l.kt)("h3",{id:"getlookuppaths"},(0,l.kt)("inlineCode",{parentName:"h3"},"getLookupPaths")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"PathResolver#getLookupPaths(): string[]")),(0,l.kt)("p",null,"Return a list of all lookup paths that have been registered."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"resolver.lookupFilePath('file.js').lookupNodeModule('module-name');\n\nconst paths = resolver.getLookupPaths(); // => ['file.js', 'module-name']\n")),(0,l.kt)("h3",{id:"lookupfilepath"},(0,l.kt)("inlineCode",{parentName:"h3"},"lookupFilePath")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"PathResolver#lookupFilePath(filePath: PortablePath, cwd?: PortablePath): this")),(0,l.kt)("p",null,"Add a file system path to look for, resolved against the defined current working directory (or\n",(0,l.kt)("inlineCode",{parentName:"p"},"process.cwd()")," otherwise)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"resolver.lookupFilePath('./some/path/to/file.js');\n")),(0,l.kt)("h3",{id:"lookupnodemodule"},(0,l.kt)("inlineCode",{parentName:"h3"},"lookupNodeModule")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"PathResolver#lookupNodeModule(modulePath: PortablePath): this")),(0,l.kt)("p",null,"Add a Node.js module, either by name or relative path, to look for."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"resolver.lookupNodeModule('module-name');\n")),(0,l.kt)("h3",{id:"resolve"},(0,l.kt)("inlineCode",{parentName:"h3"},"resolve")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"PathResolver#resolve(): { originalPath: Path; resolvedPath: Path; type: LookupType; }")),(0,l.kt)("p",null,"Given a list of lookups, attempt to find the first real/existing path and return a resolved absolute\npath. If a file system path, will check using ",(0,l.kt)("inlineCode",{parentName:"p"},"fs.exists"),". If a node module path, will check using\n",(0,l.kt)("inlineCode",{parentName:"p"},"require.resolve"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const { originalPath, resolvedPath, type } = resolver.resolve();\n")),(0,l.kt)("h3",{id:"resolvepath"},(0,l.kt)("inlineCode",{parentName:"h3"},"resolvePath")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"PathResolver#resolvePath(): Path")),(0,l.kt)("p",null,"Like ",(0,l.kt)("inlineCode",{parentName:"p"},"resolve()")," but only returns the resolved path."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const resolvedPath = resolver.resolvePath();\n")))}d.isMDXComponent=!0}}]);