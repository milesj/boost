(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[305],{5318:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return m}});var r=n(7378);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=s(n),m=o,h=d["".concat(p,".").concat(m)]||d[m]||u[m]||a;return n?r.createElement(h,i(i({ref:t},l),{},{components:n})):r.createElement(h,i({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6193:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return l},default:function(){return d}});var r=n(9603),o=n(120),a=(n(7378),n(5318)),i=["components"],c={title:"Contract"},p=void 0,s={unversionedId:"common/contract",id:"common/contract",isDocsHomePage:!1,title:"Contract",description:"A Contract is an abstract class that implements the Optionable interface, which provides an",source:"@site/docs/common/contract.md",sourceDirName:"common",slug:"/common/contract",permalink:"/docs/common/contract",editUrl:"https://github.com/milesj/boost/edit/master/website/docs/common/contract.md",version:"current",frontMatter:{title:"Contract"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/common"},next:{title:"PackageGraph",permalink:"/docs/common/package-graph"}},l=[{value:"Required options",id:"required-options",children:[]},{value:"API",id:"api",children:[{value:"<code>blueprint</code>",id:"blueprint",children:[]},{value:"<code>configure</code>",id:"configure",children:[]}]}],u={toc:l};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"Contract")," is an abstract class that implements the ",(0,a.kt)("inlineCode",{parentName:"p"},"Optionable")," interface, which provides an\noptions object layer, and is meant to be inherited from as a super class. All classes that extend\n",(0,a.kt)("inlineCode",{parentName:"p"},"Contract")," accept an options object through the constructor, which is validated and built using\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/milesj/optimal"},"optimal"),"."),(0,a.kt)("p",null,"To start, extend ",(0,a.kt)("inlineCode",{parentName:"p"},"Contract")," with a generic interface that represents the shape of the options\nobject. Next, implement the abstract ",(0,a.kt)("inlineCode",{parentName:"p"},"Contract#blueprint()")," method, which is passed\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/milesj/optimal/blob/master/docs/predicates.md"},"optimal predicates")," as an\nargument, and must return an\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/milesj/optimal/blob/master/docs/usage.md#blueprint"},"optimal blueprint")," that\nmatches the generic interface."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Contract, Blueprint, Predicates } from '@boost/common';\n\nexport interface AdapterOptions {\n    name?: string;\n    priority?: number;\n}\n\nexport default class Adapter extends Contract<AdapterOptions> {\n    blueprint({ number, string }: Predicates): Blueprint<AdapterOptions> {\n        return {\n            name: string().notEmpty(),\n            priority: number().gte(0),\n        };\n    }\n}\n")),(0,a.kt)("p",null,"When the class is instantiated, the provided values will be checked and validated using the\nblueprint. If invalid, an error will be thrown. Furthermore, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Contract#options")," property is\n",(0,a.kt)("inlineCode",{parentName:"p"},"readonly"),", and will error when mutated."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const adapter = new Adapter({\n    name: 'Boost',\n});\n\nconst { name } = adapter.options; // => Boost\n")),(0,a.kt)("h2",{id:"required-options"},"Required options"),(0,a.kt)("p",null,"By default, the options argument in the constructor is optional, and if your interface has a\nrequired property, it will not be bubbled up in TypeScript. To support this, the constructor will\nneed to be overridden so that the argument can be marked as non-optional."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export interface AdapterOptions {\n    name: string;\n    priority?: number;\n}\n\nexport default class Adapter extends Contract<AdapterOptions> {\n    constructor(options: AdapterOptions) {\n        super(options);\n    }\n\n    // ...\n}\n")),(0,a.kt)("h2",{id:"api"},"API"),(0,a.kt)("h3",{id:"blueprint"},(0,a.kt)("inlineCode",{parentName:"h3"},"blueprint")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Contract#blueprint(predicates: Predicates, onConstruction: boolean): Blueprint<T",">")),(0,a.kt)("p",null,"Shape of the options object passed to the constructor or to ",(0,a.kt)("inlineCode",{parentName:"p"},"Contract#configure()"),". Utilizes\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/milesj/optimal"},"optimal")," for strict and thorough validation checks."),(0,a.kt)("p",null,"A boolean is passed as the 2nd argument to determine whether this is validating on class\ninstantiation (first time), or by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"configure()")," (all other times)."),(0,a.kt)("h3",{id:"configure"},(0,a.kt)("inlineCode",{parentName:"h3"},"configure")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Contract#configure(options?: Partial<T",">"," | ((options: Required<T",">",") => Partial<T",">",")):\nReadonly<Required<T",">",">")),(0,a.kt)("p",null,"Use this method to modify the options object after instantiation. This method accepts a partial\nobject, or a function that receives the current full options object and must return a partial\nobject."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"adapter.configure({ name: 'Boost' });\n\nadapter.configure((prevOptions) => ({\n    nestedObject: {\n        ...prevOptions.nestedObject,\n        some: 'value',\n    },\n}));\n")))}d.isMDXComponent=!0}}]);