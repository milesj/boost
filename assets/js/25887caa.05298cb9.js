(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[696],{5318:function(e,t,a){"use strict";a.d(t,{Zo:function(){return c},kt:function(){return d}});var n=a(7378);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=s(a),d=o,m=u["".concat(p,".").concat(d)]||u[d]||h[d]||r;return a?n.createElement(m,l(l({ref:t},c),{},{components:a})):n.createElement(m,l({ref:t},c))}));function d(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,l=new Array(r);l[0]=u;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var s=2;s<r;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9121:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return u}});var n=a(9603),o=a(120),r=(a(7378),a(5318)),l=["components"],i={title:"Path"},p=void 0,s={unversionedId:"common/path",id:"common/path",isDocsHomePage:!1,title:"Path",description:"A Path class is an immutable abstraction around file/module paths and the Node.js fs and path",source:"@site/docs/common/path.md",sourceDirName:"common",slug:"/common/path",permalink:"/docs/common/path",editUrl:"https://github.com/milesj/boost/edit/master/website/docs/common/path.md",version:"current",frontMatter:{title:"Path"},sidebar:"docs",previous:{title:"PackageGraph",permalink:"/docs/common/package-graph"},next:{title:"PathResolver",permalink:"/docs/common/path-resolver"}},c=[{value:"Resolved paths",id:"resolved-paths",children:[]},{value:"Static factories",id:"static-factories",children:[]},{value:"API",id:"api",children:[{value:"<code>.create</code>",id:"create",children:[]},{value:"<code>.resolve</code>",id:"resolve",children:[]},{value:"<code>append</code>",id:"append",children:[]},{value:"<code>equals</code>",id:"equals",children:[]},{value:"<code>ext</code>",id:"ext",children:[]},{value:"<code>exists</code>",id:"exists",children:[]},{value:"<code>isAbsolute</code>",id:"isabsolute",children:[]},{value:"<code>isDirectory</code>",id:"isdirectory",children:[]},{value:"<code>isFile</code>",id:"isfile",children:[]},{value:"<code>name</code>",id:"name",children:[]},{value:"<code>parent</code>",id:"parent",children:[]},{value:"<code>path</code>",id:"path",children:[]},{value:"<code>prepend</code>",id:"prepend",children:[]},{value:"<code>relativeTo</code>",id:"relativeto",children:[]},{value:"<code>toString</code>",id:"tostring",children:[]}]}],h={toc:c};function u(e){var t=e.components,a=(0,o.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," class is an immutable abstraction around file/module paths and the Node.js ",(0,r.kt)("inlineCode",{parentName:"p"},"fs")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"path"),"\nmodules. It aims to solve cross platform and operating system related issues in a straight forward\nway. To begin, import and instantiate the ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," class, with either a single path, or a list of path\nparts that will be joined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Path } from '@boost/common';\n\nconst absPath = new Path('/root/some/path');\nconst relPath = new Path('some/path', '../move/around', 'again');\n")),(0,r.kt)("h2",{id:"resolved-paths"},"Resolved paths"),(0,r.kt)("p",null,"By default, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," class operates on the defined path parts as-is. If you would prefer to\noperate against real or resolved paths, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Path#realPath()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Path#resolve()")," methods\nrespectively. The current path is\n",(0,r.kt)("a",{parentName:"p",href:"https://nodejs.org/api/path.html#path_path_resolve_paths"},"resolved against")," the defined current\nworking directory (",(0,r.kt)("inlineCode",{parentName:"p"},"process.cwd()"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"path.path(); // Possibly inaccurate\npath.resolve().path(); // Resolved accurately\n")),(0,r.kt)("h2",{id:"static-factories"},"Static factories"),(0,r.kt)("p",null,"The static ",(0,r.kt)("inlineCode",{parentName:"p"},"Path.create()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Path.resolve()")," methods can be used to factory a ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," instance\nfrom a string or an existing instance. Especially useful when used in combination with the\n",(0,r.kt)("inlineCode",{parentName:"p"},"PortablePath")," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"Path.create('some/file/path'); // Path\n")),(0,r.kt)("h2",{id:"api"},"API"),(0,r.kt)("p",null,"The following methods are available on the class instance. In the examples below, the ",(0,r.kt)("inlineCode",{parentName:"p"},"PortablePath"),"\ntype is a union of ",(0,r.kt)("inlineCode",{parentName:"p"},"FilePath | Path"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"FilePath")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,r.kt)("h3",{id:"create"},(0,r.kt)("inlineCode",{parentName:"h3"},".create")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path.create(filePath: PortablePath): Path")),(0,r.kt)("p",null,"Create and return a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," instance if a string. If already a ",(0,r.kt)("inlineCode",{parentName:"p"},"Path"),", return as is."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = Path.create('foo');\nconst b = Path.create(new Path('bar'));\n")),(0,r.kt)("h3",{id:"resolve"},(0,r.kt)("inlineCode",{parentName:"h3"},".resolve")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path.resolve(filePath: PortablePath, cwd?: PortablePath): Path")),(0,r.kt)("p",null,"Like ",(0,r.kt)("inlineCode",{parentName:"p"},"create()")," but also resolves the path against the current working directory (defaults to\n",(0,r.kt)("inlineCode",{parentName:"p"},"process.cwd()"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const path = Path.resolve('foo', '/cwd'); // => /cwd/foo\n")),(0,r.kt)("h3",{id:"append"},(0,r.kt)("inlineCode",{parentName:"h3"},"append")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#append(...parts: PortablePath[]): Path")),(0,r.kt)("p",null,"Append path parts to the end of the current path and return a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Path('foo', 'bar'); // => foo/bar\nconst b = a.append('baz'); // => foo/bar/baz\n")),(0,r.kt)("h3",{id:"equals"},(0,r.kt)("inlineCode",{parentName:"h3"},"equals")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#equals(path: PortablePath): boolean")),(0,r.kt)("p",null,"Returns true if both paths are equal using strict equality."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Path('foo');\nconst b = new Path('bar');\n\na.equals(b); // => false\n")),(0,r.kt)("h3",{id:"ext"},(0,r.kt)("inlineCode",{parentName:"h3"},"ext")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#ext(withoutPeriod?: boolean): string")),(0,r.kt)("p",null,"Return the extension (if applicable) with or without leading period."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const path = new Path('some/path/to/file.js');\n\npath.ext(); // => .js\npath.ext(true); // => js\n")),(0,r.kt)("h3",{id:"exists"},(0,r.kt)("inlineCode",{parentName:"h3"},"exists")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#exists(): boolean")),(0,r.kt)("p",null,"Return true if the current path exists on the file system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const path = new Path('some/path/to/file.js');\n\npath.exists(); // => false\n")),(0,r.kt)("h3",{id:"isabsolute"},(0,r.kt)("inlineCode",{parentName:"h3"},"isAbsolute")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#isAbsolute(): boolean")),(0,r.kt)("p",null,"Return true if the current path is absolute. ",(0,r.kt)("em",{parentName:"p"},"Does not")," verify existence on the file system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const nixPath = new Path('/some/path/to/file.js');\nconst winPath = new Path('C:/some/path/to/file.js');\n\nnixPath.exists(); // => true\nwinPath.exists(); // => true\n")),(0,r.kt)("h3",{id:"isdirectory"},(0,r.kt)("inlineCode",{parentName:"h3"},"isDirectory")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#isDirectory(): boolean")),(0,r.kt)("p",null,"Return true if the current path is a folder."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const filePath = new Path('some/path/to/file.js');\nconst folderPath = new Path('some/path/to/folder');\n\nfilePath.isDirectory(); // => false\nfolderPath.isDirectory(); // => true\n")),(0,r.kt)("h3",{id:"isfile"},(0,r.kt)("inlineCode",{parentName:"h3"},"isFile")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#isFile(): boolean")),(0,r.kt)("p",null,"Return true if the current path is a file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const filePath = new Path('some/path/to/file.js');\nconst folderPath = new Path('some/path/to/folder');\n\nfilePath.isFile(); // => true\nfolderPath.isFile(); // => false\n")),(0,r.kt)("h3",{id:"name"},(0,r.kt)("inlineCode",{parentName:"h3"},"name")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#name(withoutExtension?: boolean): string")),(0,r.kt)("p",null,"Return the file name (with optional extension) or folder name."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const path = new Path('some/path/to/file.js');\n\npath.name(); // => file.js\npath.name(true); // => file\n")),(0,r.kt)("h3",{id:"parent"},(0,r.kt)("inlineCode",{parentName:"h3"},"parent")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#parent(): Path")),(0,r.kt)("p",null,"Return the parent folder as a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const path = new Path('foo/bar/baz');\nconst parent = path.parent(); // => foo/bar\n")),(0,r.kt)("h3",{id:"path"},(0,r.kt)("inlineCode",{parentName:"h3"},"path")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#path(): FilePath")),(0,r.kt)("p",null,"Return the current path as a normalized string. Is also triggered when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," instance is cast\nto a string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const path = new Path('foo/bar/baz');\n\npath.path(); // => foo/bar/bar\n")),(0,r.kt)("h3",{id:"prepend"},(0,r.kt)("inlineCode",{parentName:"h3"},"prepend")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#prepend(...parts: PortablePath[]): Path")),(0,r.kt)("p",null,"Prepend path parts to the beginning of the current path and return a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Path('foo', 'bar'); // => foo/bar\nconst b = a.append('baz'); // => bar/foo/bar\n")),(0,r.kt)("h3",{id:"relativeto"},(0,r.kt)("inlineCode",{parentName:"h3"},"relativeTo")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#relativeTo(to: PortablePath): Path")),(0,r.kt)("p",null,"Return a new relative ",(0,r.kt)("inlineCode",{parentName:"p"},"Path"),' instance from the current "from" path to the defined "to" path.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const from = new Path('/foo/bar/baz');\nconst to = from.relativeTo('/foo/qux'); // => ../../qux\n")),(0,r.kt)("h3",{id:"tostring"},(0,r.kt)("inlineCode",{parentName:"h3"},"toString")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Path#toString(): FilePath")),(0,r.kt)("p",null,"Return the current path as a normalized string. See ",(0,r.kt)("a",{parentName:"p",href:"#path"},"path()"),"."))}u.isMDXComponent=!0}}]);