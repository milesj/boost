(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3494],{297:function(e,a,t){"use strict";t.d(a,{Z:function(){return o}});var n=t(7378);function o(e){var a=e.children,t=e.type;return n.createElement("span",{className:"badge badge--"+t},a)}},7586:function(e,a,t){"use strict";t.d(a,{Z:function(){return c}});var n=t(7378),o=t(4142),r=t(1554),s=t(297),i="badgeGroup_2HOO",l="apiLink_32Vk";function p(e){var a=e.children;return n.createElement("span",{className:i},a)}function c(e){var a=e.api,t=e.backend,i=e.frontend,c=e.tooling;return n.createElement(n.Fragment,null,a&&n.createElement(o.default,{className:l,to:a},"API ",n.createElement(r.Z,null)),n.createElement(p,null,t&&n.createElement(s.Z,{type:"warning"},"Backend"),i&&n.createElement(s.Z,{type:"success"},"Frontend"),c&&n.createElement(s.Z,{type:"primary"},"Tooling")))}},1808:function(e,a,t){"use strict";t.r(a),t.d(a,{frontMatter:function(){return c},contentTitle:function(){return m},metadata:function(){return d},toc:function(){return h},default:function(){return k}});var n=t(9603),o=t(120),r=(t(7378),t(5318)),s=t(7586),i=t(4535),l=t(517),p=["components"],c={title:"Common utilities"},m=void 0,d={unversionedId:"common",id:"common",isDocsHomePage:!1,title:"Common utilities",description:"A collection of common utilities, classes, and helpers.",source:"@site/docs/common.mdx",sourceDirName:".",slug:"/common",permalink:"/docs/common",editUrl:"https://github.com/milesj/boost/edit/master/website/docs/common.mdx",tags:[],version:"current",frontMatter:{title:"Common utilities"},sidebar:"docs",previous:{title:"Prompts",permalink:"/docs/cli/prompts"},next:{title:"Configuration",permalink:"/docs/config"}},h=[{value:"Installation",id:"installation",children:[]},{value:"Helpers and serializers",id:"helpers-and-serializers",children:[]},{value:"Class contracts",id:"class-contracts",children:[{value:"Required options",id:"required-options",children:[]}]},{value:"Project management",id:"project-management",children:[{value:"Workspaces",id:"workspaces",children:[]},{value:"Package graph",id:"package-graph",children:[]}]},{value:"Path management",id:"path-management",children:[{value:"Static factories",id:"static-factories",children:[]},{value:"Resolving lookup paths",id:"resolving-lookup-paths",children:[]}]}],u={toc:h};function k(e){var a=e.components,t=(0,o.Z)(e,p);return(0,r.kt)("wrapper",(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)(s.Z,{backend:!0,tooling:!0,api:"/api/common",mdxType:"EnvBadges"}),(0,r.kt)("p",null,"A collection of common utilities, classes, and helpers."),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)(i.Z,{groupId:"package-manager",defaultValue:"yarn",values:[{label:"Yarn",value:"yarn"},{label:"npm",value:"npm"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"yarn",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add @boost/common\n"))),(0,r.kt)(l.Z,{value:"npm",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @boost/common\n")))),(0,r.kt)("h2",{id:"helpers-and-serializers"},"Helpers and serializers"),(0,r.kt)("p",null,"Boost provides many functions for common scenarios and patterns, like\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/function/isObject"},(0,r.kt)("inlineCode",{parentName:"a"},"isObject"))," for verifying a value is an object, or\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/function/toArray"},(0,r.kt)("inlineCode",{parentName:"a"},"toArray"))," for converting a value to an array.\n",(0,r.kt)("a",{parentName:"p",href:"/api/common#Functions"},"View the API for a full list of functions with examples"),"."),(0,r.kt)("h4",{id:"json"},"JSON"),(0,r.kt)("p",null,"Powered by the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/json5"},"JSON5")," package, the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/namespace/json"},(0,r.kt)("inlineCode",{parentName:"a"},"json"))," serializer can be used to parse and stringify JSON data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { json } from '@boost/common';\n\njson.parse(data);\njson.stringify(data);\n")),(0,r.kt)("h4",{id:"yaml"},"YAML"),(0,r.kt)("p",null,"Powered by the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/yaml"},"YAML")," package, the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/namespace/yaml"},(0,r.kt)("inlineCode",{parentName:"a"},"yaml"))," serializer can be used to parse and stringify YAML data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { yaml } from '@boost/common';\n\nyaml.parse(data);\nyaml.stringify(data);\n")),(0,r.kt)("h2",{id:"class-contracts"},"Class contracts"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Contract"},(0,r.kt)("inlineCode",{parentName:"a"},"Contract")),"is an abstract class that implements the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/interface/Optionable"},(0,r.kt)("inlineCode",{parentName:"a"},"Optionable"))," interface, which provides an options object layer,\nand is meant to be inherited from as a super class. All classes that extend ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Contract"},(0,r.kt)("inlineCode",{parentName:"a"},"Contract")),"\naccept an options object through the constructor, which is validated and built using\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/milesj/optimal"},"optimal"),"."),(0,r.kt)("p",null,"To start, extend ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Contract"},(0,r.kt)("inlineCode",{parentName:"a"},"Contract"))," with a generic interface that represents the shape of the\noptions object. Next, implement the abstract\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Contract#blueprint"},(0,r.kt)("inlineCode",{parentName:"a"},"Contract#blueprint()"))," method, which is passed\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/milesj/optimal/blob/master/docs/schemas.md"},"optimal schemas")," as an argument, and\nmust return an\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/milesj/optimal/blob/master/docs/usage.md#blueprint"},"optimal blueprint")," that\nmatches the generic interface."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Contract, Blueprint, Schemas } from '@boost/common';\n\nexport interface AdapterOptions {\n    name?: string;\n    priority?: number;\n}\n\nexport default class Adapter extends Contract<AdapterOptions> {\n    blueprint({ number, string }: Schemas): Blueprint<AdapterOptions> {\n        return {\n            name: string().notEmpty(),\n            priority: number().gte(0),\n        };\n    }\n}\n")),(0,r.kt)("p",null,"When the class is instantiated, the provided values will be checked and validated using the\nblueprint. If invalid, an error will be thrown. Furthermore, the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Contract#options"},(0,r.kt)("inlineCode",{parentName:"a"},"Contract#options"))," property is ",(0,r.kt)("inlineCode",{parentName:"p"},"readonly"),", and will error when\nmutated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const adapter = new Adapter({\n    name: 'Boost',\n});\n\nconst { name } = adapter.options; // => Boost\n")),(0,r.kt)("h3",{id:"required-options"},"Required options"),(0,r.kt)("p",null,"By default, the options argument in the constructor is optional, and if your interface has a\nrequired property, it will not be bubbled up in TypeScript. To support this, the constructor will\nneed to be overridden so that the argument can be marked as non-optional."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export interface AdapterOptions {\n    name: string;\n    priority?: number;\n}\n\nexport default class Adapter extends Contract<AdapterOptions> {\n    constructor(options: AdapterOptions) {\n        super(options);\n    }\n\n    // ...\n}\n")),(0,r.kt)("h2",{id:"project-management"},"Project management"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Project"},(0,r.kt)("inlineCode",{parentName:"a"},"Project"))," class provides workspace and package metadata for a project. A project is\ndenoted by a root ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," file and abides the npm and Node.js module pattern. To begin,\nimport and instantiate the ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Project"},(0,r.kt)("inlineCode",{parentName:"a"},"Project"))," class with a path to the project's root."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Project } from '@boost/common';\n\nconst project = new Project();\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Root defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"process.cwd()")," if not provided.")),(0,r.kt)("h3",{id:"workspaces"},"Workspaces"),(0,r.kt)("p",null,"The primary feature of this class is to extract metadata about a project's workspaces. Workspaces\nare used to support multi-package architectures known as monorepos, typically through\n",(0,r.kt)("a",{parentName:"p",href:"https://yarnpkg.com/features/workspaces"},"Yarn"),", ",(0,r.kt)("a",{parentName:"p",href:"https://pnpm.js.org/en/pnpm-workspace_yaml"},"PNPM"),",\nor ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/lerna/lerna#lernajson"},"Lerna"),". In Boost, our implementation of workspaces\naligns with:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Project")," - Typically a repository with a root ",(0,r.kt)("inlineCode",{parentName:"li"},"package.json"),". Can either be a collection of\npackages, or a package itself."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Package")," - A folder with a ",(0,r.kt)("inlineCode",{parentName:"li"},"package.json")," file that represents an npm package. Contains source\nand test files specific to the package."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Workspace")," - A folder that houses one or many packages.")),(0,r.kt)("h3",{id:"package-graph"},"Package graph"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/PackageGraph"},(0,r.kt)("inlineCode",{parentName:"a"},"PackageGraph"))," class can be used to generate a dependency graph for a list of\npackages, based on their defined ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"peerDependencies"),". To begin, import and\ninstantiate the class, which accepts a list of optional ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," objects as the 1st argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { PackageGraph } from '@boost/common';\n\nconst graph = new PackageGraph([\n    {\n        name: '@boost/common',\n        version: '1.2.3',\n    },\n    {\n        name: '@boost/cli',\n        version: '1.0.0',\n        dependencies: {\n            '@boost/common': '^1.0.0',\n        },\n    },\n]);\n")),(0,r.kt)("p",null,"Once all packages have been defined, we can resolve our graph into 1 of 3 formats, using the\nfollowing methods. ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/PackageGraph"},"View the API for more information on these methods"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const batch = graph.resolveBatchList();\nconst list = graph.resolveList();\nconst tree = graph.resolveTree();\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Will only resolve and return packages that have been defined. Will ",(0,r.kt)("em",{parentName:"p"},"not")," return non-defined\npackages found in ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"peerDependencies"),".")),(0,r.kt)("h2",{id:"path-management"},"Path management"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path"},(0,r.kt)("inlineCode",{parentName:"a"},"Path"))," class is an immutable abstraction around file/module paths and the Node.js ",(0,r.kt)("inlineCode",{parentName:"p"},"fs"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"path")," modules. It aims to solve cross platform and operating system related issues in a\nstraight forward way. To begin, import and instantiate the ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path"},(0,r.kt)("inlineCode",{parentName:"a"},"Path"))," class, with either a\nsingle path, or a list of path parts that will be joined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Path } from '@boost/common';\n\nconst absPath = new Path('/root/some/path');\nconst relPath = new Path('some/path', '../move/around', 'again');\n")),(0,r.kt)("p",null,"By default, the class operates on the defined path parts as-is. If you would prefer to operate\nagainst real or resolved paths, use the ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path#realPath"},(0,r.kt)("inlineCode",{parentName:"a"},"Path#realPath()"))," and\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path#resolve"},(0,r.kt)("inlineCode",{parentName:"a"},"Path#resolve()"))," methods respectively. The current path is\n",(0,r.kt)("a",{parentName:"p",href:"https://nodejs.org/api/path.html#path_path_resolve_paths"},"resolved against")," the defined current\nworking directory (",(0,r.kt)("inlineCode",{parentName:"p"},"process.cwd()"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"path.path(); // Possibly inaccurate\npath.resolve().path(); // Resolved accurately\n")),(0,r.kt)("p",null,"With that being said, the class supports many convenient methods.\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path"},"View the API for a full list"),"."),(0,r.kt)("h3",{id:"static-factories"},"Static factories"),(0,r.kt)("p",null,"The static ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path#create"},(0,r.kt)("inlineCode",{parentName:"a"},"Path.create()"))," and\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path#resolve"},(0,r.kt)("inlineCode",{parentName:"a"},"Path.resolve()"))," methods can be used to factory a ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path"},(0,r.kt)("inlineCode",{parentName:"a"},"Path")),"\ninstance from a string or an existing instance. Especially useful when used in combination with the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common#PortablePath"},(0,r.kt)("inlineCode",{parentName:"a"},"PortablePath"))," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"Path.create('some/file/path'); // Path\n")),(0,r.kt)("h3",{id:"resolving-lookup-paths"},"Resolving lookup paths"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/PathResolver"},(0,r.kt)("inlineCode",{parentName:"a"},"PathResolver"))," class can be used to find a real path amongst a list of possible\nlookups. A lookup is either a file system path or a Node.js module. If a path is found, an absolute\nresolved ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path"},(0,r.kt)("inlineCode",{parentName:"a"},"Path"))," instance is returned, otherwise an error is thrown."),(0,r.kt)("p",null,"A perfect scenario for this mechanism would be finding a valid configuration file, which we'll\ndemonstrate below. Import and instantiate the class to begin."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { PathResolver } from '@boost/common';\n\nconst resolver = new PathResolver();\n\n// With a custom module resolver (can be async!)\nconst resolver = new PathResolver(customResolver);\n")),(0,r.kt)("p",null,"To add a file system lookup, use the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/PathResolver#lookupFilePath"},(0,r.kt)("inlineCode",{parentName:"a"},"PathResolver#lookupFilePath()"))," method, which\nrequires a path and an optional current working directory (defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"process.cwd()"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Look in current directory\nresolver\n    .lookupFilePath('tool.config.js')\n    .lookupFilePath('tool.config.json')\n    .lookupFilePath('tool.config.yaml');\n\n// Look in a folder\nresolver.lookupFilePath('configs/tool.js');\n\n// Look in user's home directory\nresolver.lookupFilePath('tool.config.js', os.homedir());\n")),(0,r.kt)("p",null,"And to add a Node.js module lookup, use the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/PathResolver#lookupNodeModule"},(0,r.kt)("inlineCode",{parentName:"a"},"PathResolver#lookupNodeModule()"))," method, which\naccepts a module name or path."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Look in module (assuming index export)\nresolver.lookupNodeModule('tool-config-module');\n\n// Look in module with sub-path\nresolver.lookupNodeModule('tool-config-module/lib/configs/tool.js');\n")),(0,r.kt)("p",null,"Once all the lookup paths have been defined, the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/PathResolver#resolve"},(0,r.kt)("inlineCode",{parentName:"a"},"PathResolver#resolve()"))," method will iterate through them\nin order until one is found. If a file system path, ",(0,r.kt)("inlineCode",{parentName:"p"},"fs.existsSync()")," will be used to check for\nexistence, while the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/resolve"},(0,r.kt)("inlineCode",{parentName:"a"},"resolve"))," npm package will be used for\nNode.js modules. If found, a result object will be returned with the resolved ",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/Path"},(0,r.kt)("inlineCode",{parentName:"a"},"Path"))," and\noriginal lookup parts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { originalSource, resolvedPath, type } = await resolver.resolve();\n")),(0,r.kt)("p",null,"If you'd prefer to only have the resolved path returned, the\n",(0,r.kt)("a",{parentName:"p",href:"/api/common/class/PathResolver#resolvePath"},(0,r.kt)("inlineCode",{parentName:"a"},"PathResolver#resolvePath()"))," method can be used\ninstead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const resolvedPath = await resolver.resolvePath();\n")))}k.isMDXComponent=!0}}]);