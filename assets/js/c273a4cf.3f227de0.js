"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4960],{8072:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>g,frontMatter:()=>l,metadata:()=>d,toc:()=>u});var s=r(1948),a=r(3460),t=r(302),i=r(240),o=r(2548);const l={title:"Arguments"},c=void 0,d={id:"args",title:"Arguments",description:"A type-safe and convention based argument parsing library, with strict validation checks.",source:"@site/docs/args.mdx",sourceDirName:".",slug:"/args",permalink:"/docs/args",draft:!1,unlisted:!1,editUrl:"https://github.com/milesj/boost/edit/master/website/docs/args.mdx",tags:[],version:"current",frontMatter:{title:"Arguments"},sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/"},next:{title:"Overview",permalink:"/docs/cli"}},h={},u=[{value:"Installation",id:"installation",level:2},{value:"Parsing",id:"parsing",level:2},{value:"Contextual parsing",id:"contextual-parsing",level:3},{value:"Commands",id:"commands",level:2},{value:"Options",id:"options",level:2},{value:"Single value",id:"single-value",level:3},{value:"Multiple values",id:"multiple-values",level:3},{value:"Unknown options",id:"unknown-options",level:3},{value:"Flags",id:"flags",level:2},{value:"Params",id:"params",level:2},{value:"Variadic params",id:"variadic-params",level:3},{value:"Rest args",id:"rest-args",level:2},{value:"Advanced",id:"advanced",level:2},{value:"Short option groups",id:"short-option-groups",level:3},{value:"Counter options",id:"counter-options",level:3},{value:"Choice options",id:"choice-options",level:3},{value:"Arity requirements",id:"arity-requirements",level:3},{value:"Command &amp; option categories",id:"command--option-categories",level:3},{value:"Loose mode",id:"loose-mode",level:3},{value:"Type casting",id:"type-casting",level:2},{value:"Validation checks",id:"validation-checks",level:2},{value:"Formatting args",id:"formatting-args",level:2}];function p(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.c,{tooling:!0,api:"/api/args"}),"\n",(0,s.jsx)(n.p,{children:"A type-safe and convention based argument parsing library, with strict validation checks."}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsxs)(i.c,{groupId:"package-manager",defaultValue:"yarn",values:[{label:"Yarn",value:"yarn"},{label:"pnpm",value:"pnpm"},{label:"npm",value:"npm"}],children:[(0,s.jsx)(o.c,{value:"yarn",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yarn add @boost/args\n"})})}),(0,s.jsx)(o.c,{value:"pnpm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pnpm add @boost/args\n"})})}),(0,s.jsx)(o.c,{value:"npm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @boost/args\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"parsing",children:"Parsing"}),"\n",(0,s.jsxs)(n.p,{children:["This library is strict parser for command line arguments, primarily ",(0,s.jsx)(n.code,{children:"process.argv"})," in Node.js, that\nsupports ",(0,s.jsx)(n.a,{href:"#commands",children:"commands"}),", ",(0,s.jsx)(n.a,{href:"#options",children:"options"}),", ",(0,s.jsx)(n.a,{href:"#flags",children:"flags"}),", ",(0,s.jsx)(n.a,{href:"#params",children:"params"}),", and\n",(0,s.jsx)(n.a,{href:"#advanced",children:"much more"}),"! It is ",(0,s.jsx)(n.em,{children:"not"})," a command line interface or application but provides the\nbuilding blocks for such functionality."]}),"\n",(0,s.jsxs)(n.p,{children:["Parsing arguments is accomplished with the ",(0,s.jsx)(n.a,{href:"/api/args/function/parse",children:(0,s.jsx)(n.code,{children:"parse()"})})," function, which requires a list of\nstrings (arguments also known as ",(0,s.jsx)(n.code,{children:"argv"}),"), and a settings object to control whats supported. It also\nutilizes TypeScript generics to type options and params respectively."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { parse } from '@boost/args';\n\n// Remove node binary and script\nconst argv = process.argv.slice(2);\n\n// Parse argv into a consumable object\nconst { command, errors, options, params, rest } = parse<{ help: boolean }, [string]>(argv, {\n  options: {\n    help: {\n      description: 'Show the help menu',\n      short: 'H',\n      type: 'boolean',\n    },\n  },\n  params: [\n    {\n      description: 'File path to source directory',\n      label: 'Source',\n      required: true,\n      type: 'string',\n    },\n  ],\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"A command line breaks down to the following parts. This terminology pertains to Boost but is based\non common patterns seen throughout the community."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c 1 \u2510 \u250c 2 \u2510 \u250c\u2500\u2500\u2500 3 \u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500 4 \u2500\u2500\u2500\u2510 \u250c\u2500\u2500 5 \u2500\u2510 \u250c 6 \u2510 \u250c\u2500\u2500\u2500 7 \u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500 8 \u2500\u2500\u2500\u2500\u2510\nboost build --key value --key=value -flag -F -aBDc foo bar baz -- --foo bar -B\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 9 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Binary that was executed. Also known as a script, and is never passed to ",(0,s.jsx)(n.code,{children:"argv"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#commands",children:"Command"})," being executed. Should always be first."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#options",children:"Option"})," with a value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#options",children:"Option"})," with a value using an equals sign."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#flags",children:"Flag"})," in both long and short form."]}),"\n",(0,s.jsxs)(n.li,{children:["A group of ",(0,s.jsx)(n.a,{href:"#short-option-groups",children:"short options"}),", most commonly used by flags."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#params",children:"Parameters"})," passed to a command."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#rest-args",children:"Rest"})," arguments that are not parsed. Always appear after a ",(0,s.jsx)(n.code,{children:"--"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"The command line."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"contextual-parsing",children:"Contextual parsing"}),"\n",(0,s.jsx)(n.p,{children:"While the above is straight forward (I hope so), it doesn't leave much room for customization. What\nif we want different options based on the command passed? Or different params? Or how to handle\nglobal options? So on and so forth."}),"\n",(0,s.jsxs)(n.p,{children:["To provide this functionality, the ",(0,s.jsx)(n.a,{href:"/api/args/function/parseInContext",children:(0,s.jsx)(n.code,{children:"parseInContext()"})})," function can be used. Like\n",(0,s.jsx)(n.a,{href:"/api/args/function/parse",children:(0,s.jsx)(n.code,{children:"parse()"})}),", this function requires a list of strings (",(0,s.jsx)(n.code,{children:"argv"}),"), but unlike, it requires a\nfactory function that returns contextual parser options."]}),"\n",(0,s.jsx)(n.p,{children:"The parser will loop through each argument, executing the factory function with the argument and\nargv list, until a match is found and options were returned."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { parseInContext } from '@boost/args';\n\n// Remove node binary and script\nconst argv = process.argv.slice(2);\n\n// Parse argv into a consumable object\nconst { command, errors, options, params, rest } = parseInContext(argv, (arg) => {\n  // Build command found, define build specific options\n  if (arg === 'build') {\n    return {\n      command: ['build'],\n      options: {\n        dest: {\n          description: 'Destination path',\n          type: 'string',\n        },\n      },\n    };\n  }\n\n  // Install command found, require params\n  if (arg === 'install') {\n    return {\n      command: ['install'],\n      params: [\n        {\n          description: 'Package name(s)',\n          type: 'string',\n          required: true,\n        },\n      ],\n    };\n  }\n\n  return undefined;\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"commands",children:"Commands"}),"\n",(0,s.jsx)(n.p,{children:"Commands are a feature that allow for branching logic, full isolation, and distinct code paths. That\nbeing said, the parser does not handle this functionality, as that's a CLI/programs job. The parser\nhowever, will detect a command, and sub-commands, and validate them accordingly."}),"\n",(0,s.jsxs)(n.p,{children:["A command in Boost should be the first argument passed, before ",(0,s.jsx)(n.a,{href:"#options",children:"options"}),", and definitely\nbefore ",(0,s.jsx)(n.a,{href:"#params",children:"params"}),". They support numbers, letters, and dashes, with sub-commands being\nseparated by a colon (",(0,s.jsx)(n.code,{children:":"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["To detect and parse commands, pass a list of all command and sub-command names to the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/ParserOptions#commands",children:(0,s.jsx)(n.code,{children:"commands"})})," setting, or use a custom function to\nmanually do the checks. The detected command will be returned as an array, split on ",(0,s.jsx)(n.code,{children:":"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const args = parse<{}>(argv, {\n  commands: ['build', 'build:esm', 'build:cjs', 'install'],\n  // OR\n  commands(arg) {\n    return arg === 'build'; // etc\n  },\n});\n\n// build:esm src/ --out lib/\nargs.command; // ['build', 'esm']\nargs.options; // { out: 'lib/' }\nargs.params; // ['src/']\n"})}),"\n",(0,s.jsx)(n.p,{children:"If an argument is not found in the commands list or function, it will be treated as a parameter."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// build:umd src/ --out lib/\nargs.command; // []\nargs.options; // { out: 'lib/' }\nargs.params; // ['build:umd', 'src/']\n"})}),"\n",(0,s.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,s.jsxs)(n.p,{children:["An option (",(0,s.jsx)(n.a,{href:"/api/args/interface/Option",children:"API"}),") is an optional argument that accepts a single value or\nmultiple values. It has 2 forms, the first being the default form, also known as a long option,\nwhich starts with ",(0,s.jsx)(n.code,{children:"--"})," and is followed by a word or phrase (either in camel or kebab case). For\nexample, ",(0,s.jsx)(n.code,{children:"--log"}),", ",(0,s.jsx)(n.code,{children:"--log-level"}),", or ",(0,s.jsx)(n.code,{children:"--logLevel"})," (preferred)."]}),"\n",(0,s.jsxs)(n.p,{children:["The second form is known as the short form and is represented by a single alpha character (either\nlower or uppercase) prefixed with ",(0,s.jsx)(n.code,{children:"-"}),", for example, ",(0,s.jsx)(n.code,{children:"-l"})," or ",(0,s.jsx)(n.code,{children:"-L"}),". The short option can be enabled\nwith the ",(0,s.jsx)(n.a,{href:"/api/args/interface/Option#short",children:(0,s.jsx)(n.code,{children:"short"})})," setting."]}),"\n",(0,s.jsxs)(n.p,{children:["For options to parse correctly, they must be defined using a settings object that abide the\n",(0,s.jsx)(n.a,{href:"/api/cli/interface/Option",children:(0,s.jsx)(n.code,{children:"Option"})})," interface."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['--logLevel=2'];\nconst args = parse<{ logLevel: number }>(argv, {\n  options: {\n    logLevel: {\n      description: 'Increase log output verbosity',\n      type: 'number',\n      short: 'L',\n      validate(value) {\n        if (value < 0 || value > 10) {\n          throw new Error('Log level must be between 0 and 10.');\n        }\n      },\n    },\n  },\n});\n\nargs.options.logLevel; // 2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The name of options used on the command line are derived from the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/ParserOptions#options",children:(0,s.jsx)(n.code,{children:"options"})})," keys (above), which are preferred to be camel\ncase. Even though they are defined as camel case, kebab case variants are supported on the command\nline."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["When using TypeScript, a mapping of option names to expected types is defined as the 1st generic\nslot of ",(0,s.jsx)(n.code,{children:"parse()"}),". If not provided, it defaults to ",(0,s.jsx)(n.code,{children:"object"}),". It's highly encouraged to type\noptions correctly."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"single-value",children:"Single value"}),"\n",(0,s.jsxs)(n.p,{children:["A value can be passed as either an additional argument separated by a space, like ",(0,s.jsx)(n.code,{children:"--option value"}),"\n(preferred), or with an equals sign and no space (also known as an inline value), like\n",(0,s.jsx)(n.code,{children:"--option=value"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are passing a string that contains spaces or special characters, you must wrap the value in\ndouble quotes. For example, ",(0,s.jsx)(n.code,{children:'--option "long value"'})," or ",(0,s.jsx)(n.code,{children:'--option="long value"'}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/api/args/interface/SingleOption",children:"API"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"multiple-values",children:"Multiple values"}),"\n",(0,s.jsxs)(n.p,{children:["To pass multiple values for an option, the ",(0,s.jsx)(n.a,{href:"/api/args/interface/MultipleOption#multiple",children:(0,s.jsx)(n.code,{children:"multiple"})}),"\nsetting must be enabled (numbers and strings only), and if using TypeScript, the option type must be\na typed array."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const args = parse<{ files: string[] }>(argv, {\n  options: {\n    files: {\n      description: 'List of files to process',\n      multiple: true,\n      type: 'string',\n    },\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Like single values, there are 2 patterns for passing multiple values, but the semantics are slightly\ndifferent. When using inlines values (the equals sign), the option must be repeated for each value,\nlike ",(0,s.jsx)(n.code,{children:"--option=foo --option=bar --option=baz"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Otherwise, each value can be passed as a standalone argument, like ",(0,s.jsx)(n.code,{children:"--option foo bar baz"}),". When\nusing this approach, all values will be captured until another option is passed, or the end of the\nlist is met."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/api/args/interface/MultipleOption",children:"API"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"unknown-options",children:"Unknown options"}),"\n",(0,s.jsxs)(n.p,{children:["If an option is passed to ",(0,s.jsx)(n.a,{href:"/api/args/function/parse",children:(0,s.jsx)(n.code,{children:"parse()"})})," that is not configured in the ",(0,s.jsx)(n.code,{children:"options"})," settings\nobject, it will be ",(0,s.jsx)(n.a,{href:"#validation-checks",children:"logged as a parse error"})," unless the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/ParserOptions#unknown",children:(0,s.jsx)(n.code,{children:"unknown"})})," setting is set to true. When true, all\nunknown options can be found in the result's ",(0,s.jsx)(n.a,{href:"/api/args/interface/Arguments#unknown",children:(0,s.jsx)(n.code,{children:"unknown"})}),"\nobject and not in ",(0,s.jsx)(n.a,{href:"/api/args/interface/Arguments#options",children:(0,s.jsx)(n.code,{children:"options"})}),", as a means to avoid collision."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['--legit', 'foo', '--unknown', 'bar'];\nconst args = parse<{ legit: string }>(argv, {\n  options: {\n    legit: {\n      description: 'A legitimate option',\n      type: 'string',\n    },\n  },\n  unknown: true,\n});\n\nargs.options; // { legit: 'foo' }\nargs.unknown; // { unknown: 'bar' }\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Unknown short options will still throw an error, as they require a parent long option to\nreference."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"flags",children:"Flags"}),"\n",(0,s.jsxs)(n.p,{children:["A flag (",(0,s.jsx)(n.a,{href:"/api/args/interface/Flag",children:"API"}),") is a special type of ",(0,s.jsx)(n.a,{href:"#options",children:"option"})," that accepts no\nvalue, is always boolean, and represents a binary on-off switch. When the flag is passed on the\ncommand line (without a value), for example, ",(0,s.jsx)(n.code,{children:"--color"}),", the value is assumed to be ",(0,s.jsx)(n.code,{children:"true"}),". To negate\na truthy value and pass a falsy one, prefix the option with ",(0,s.jsx)(n.code,{children:"no-"}),", for example, ",(0,s.jsx)(n.code,{children:"--no-color"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Each flag settings object must abide the ",(0,s.jsx)(n.a,{href:"/api/cli/interface/Flag",children:(0,s.jsx)(n.code,{children:"Flag"})})," interface."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['--color'];\nconst args = parse<{ color: boolean }>(argv, {\n  options: {\n    color: {\n      description: 'Enable colored output',\n      type: 'boolean',\n    },\n  },\n});\n\nargs.options.color; // true\n"})}),"\n",(0,s.jsx)(n.h2,{id:"params",children:"Params"}),"\n",(0,s.jsxs)(n.p,{children:["Parameters (",(0,s.jsx)(n.a,{href:"/api/args/interface/Param",children:"API"}),"), also known as positional arguments, are standalone\narguments that are treated as values, and are parsed in a strict order. They're an important\nmechanism that serves 2 purposes."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["They're a catch all bucket for arguments that ",(0,s.jsx)(n.em,{children:"are not"})," a command, option, or flag, nor do they\nappear after a rest ",(0,s.jsx)(n.code,{children:"--"})," delimiter."]}),"\n",(0,s.jsx)(n.li,{children:"They're tightly coupled to commands (when being used). Think of a command as a function, where the\nparams are the arguments that are passed to the function."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Like ",(0,s.jsx)(n.a,{href:"#options",children:"options"}),", params can be configured, but unlike options, the settings are not\nrequired. When a setting is not defined, a param is treated as a string. Param setting objects must\nabide the ",(0,s.jsx)(n.a,{href:"/api/cli/interface/Param",children:(0,s.jsx)(n.code,{children:"Param"})})," interface."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['off', 'value', '123.45'];\nconst args = parse<{}, [boolean, string, number]>(argv, {\n  params: [\n    {\n      description: 'First parameter',\n      label: 'First',\n      type: 'boolean',\n      required: true,\n    },\n    { description: 'Second parameter', label: 'Second', type: 'string' },\n    { description: 'Third parameter', label: 'Third', type: 'number' },\n  ],\n});\n\nargs.params; // [false, 'value', 123.45]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since parameters are order based and not named based, the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/ParserOptions#params",children:(0,s.jsx)(n.code,{children:"params"})})," setting is an array, with each item configuring\nthe corresponding position/index (hence the name positional arguments)."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["When using TypeScript, the expected type of each param is defined as a tuple in the 2nd generic\nslot of ",(0,s.jsx)(n.code,{children:"parse()"}),". If not provided, it defaults to ",(0,s.jsx)(n.code,{children:"string[]"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"variadic-params",children:"Variadic params"}),"\n",(0,s.jsx)(n.p,{children:"By default the parser enables variadic params, which means that any argument that does not match a\ncommand or option, is considered a param (string only), and is appended to the end of the params\nlist. This also applies to non-configured params."}),"\n",(0,s.jsxs)(n.p,{children:['As mentioned in the previous section, params are a "catch all bucket", but this only applies when\nthe parser allows variadic params. To disable this functionality, set\n',(0,s.jsx)(n.a,{href:"/api/args/interface/ParserOptions#variadic",children:(0,s.jsx)(n.code,{children:"variadic"})})," to false, which will throw an error on any\nparam that is not explicitly configured. Both of these scenarios are demonstrated below."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Variadic, appends all params\nconst argv = ['foo', 'bar', 'baz'];\nconst args = parse<{}, [string, string, string]>(argv, {\n  params: [\n    {\n      description: 'First parameter',\n      label: 'First',\n      type: 'string',\n      required: true,\n    },\n  ],\n});\n\nargs.params; // ['foo', 'bar', 'baz']\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Not variadic, will error for non-configured params\nconst argv = ['foo', 'bar', 'baz'];\nconst args = parse<{}, [string]>(argv, {\n  params: [\n    {\n      description: 'First parameter',\n      label: 'First',\n      type: 'string',\n      required: true,\n    },\n  ],\n  variadic: false,\n});\n\nargs.params; // ['foo']\n"})}),"\n",(0,s.jsx)(n.h2,{id:"rest-args",children:"Rest args"}),"\n",(0,s.jsxs)(n.p,{children:["Rest arguments are rather simple, as they're everything after a standalone ",(0,s.jsx)(n.code,{children:"--"})," argument (also known\nas ",(0,s.jsx)(n.a,{href:"https://unix.stackexchange.com/questions/147143/when-and-how-was-the-double-dash-introduced-as-an-end-of-options-delimiter",children:"end of options delimiter"}),"). They are ",(0,s.jsx)(n.em,{children:"not"})," parsed and are usually passed to\nsubsequent scripts or commands."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const args = parse(['foo', 'bar', '--', 'baz']);\n\nargs.params; // ['foo', 'bar']\nargs.rest; // ['baz']\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced",children:"Advanced"}),"\n",(0,s.jsx)(n.h3,{id:"short-option-groups",children:"Short option groups"}),"\n",(0,s.jsxs)(n.p,{children:["Short options support a shortcut known as a short option group, where multiple short option names\ncan be placed under a single leading ",(0,s.jsx)(n.code,{children:"-"}),". For example, instead of passing ",(0,s.jsx)(n.code,{children:"-a -b -c"}),", you can pass\n",(0,s.jsx)(n.code,{children:"-abc"}),". This shortcut is only available for ",(0,s.jsx)(n.a,{href:"#flags",children:"flags"})," (boolean options) and\n",(0,s.jsx)(n.a,{href:"#counter-options",children:"counters"})," (numeric options with\n",(0,s.jsx)(n.a,{href:"/api/args/interface/SingleOption#count",children:(0,s.jsx)(n.code,{children:"count"})}),"), otherwise an error is thrown."]}),"\n",(0,s.jsxs)(n.p,{children:["When passing flags within a group, it will mark the value as ",(0,s.jsx)(n.code,{children:"true"}),". Flag negation is not supported\nwithin a group."]}),"\n",(0,s.jsx)(n.h3,{id:"counter-options",children:"Counter options"}),"\n",(0,s.jsxs)(n.p,{children:["Counters are a ",(0,s.jsx)(n.code,{children:"number"})," option only feature, where each occurence of the option in a short option\ngroup will increment the option's value (starting from the ",(0,s.jsx)(n.code,{children:"default"})," value). For example, passing\n",(0,s.jsx)(n.code,{children:"-vvv"}),' will increment the value 3 times, once for each "v", resulting in a sum of 3. If not using a\ngroup, the numeric value will need to be explicitly passed, like ',(0,s.jsx)(n.code,{children:"--verbose 3"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To make use of this feature, enable the ",(0,s.jsx)(n.a,{href:"/api/args/interface/SingleOption#count",children:(0,s.jsx)(n.code,{children:"count"})})," setting on\na numeric option."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['-vvv'];\nconst args = parse<{ verbose: number }>(argv, {\n  options: {\n    verbose: {\n      count: true,\n      default: 0,\n      description: 'Increase output verbosity',\n      short: 'v',\n      type: 'number',\n    },\n  },\n});\n\nargs.options.verbose; // 3\n"})}),"\n",(0,s.jsx)(n.h3,{id:"choice-options",children:"Choice options"}),"\n",(0,s.jsxs)(n.p,{children:["For scenarios where you want to only accept an option value from a pre-defined list of choices, the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/SingleOption#choices",children:(0,s.jsx)(n.code,{children:"choices"})})," setting can be used (single number/string\nvalues only). If an unsupported value is provided, the parser will throw an error."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['--modules', 'umd'];\nconst args = parse<{ modules: 'cjs' | 'esm' | 'umd' }>(argv, {\n  options: {\n    modules: {\n      choices: ['cjs', 'esm', 'umd'] as 'esm'[],\n      default: 'esm',\n      description: 'Choose module output',\n      type: 'string',\n    },\n  },\n});\n\nargs.options.modules; // 'umd'\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["TypeScript doesn't handle the mapping of unions very well, so we need to ",(0,s.jsx)(n.code,{children:"as"})," the ",(0,s.jsx)(n.code,{children:"choices"}),"\nsetting. This isn't necessary when using a non-union."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"arity-requirements",children:"Arity requirements"}),"\n",(0,s.jsxs)(n.p,{children:["Another scenario may require an exact number of ",(0,s.jsx)(n.a,{href:"#multiple-values",children:"option values"}),", otherwise an\nerror is thrown. This feature is known as arity (like function argument arity), and can be enabled\nwith the ",(0,s.jsx)(n.a,{href:"/api/args/interface/MultipleOption#arity",children:(0,s.jsx)(n.code,{children:"arity"})})," +\n",(0,s.jsx)(n.a,{href:"/api/args/interface/MultipleOption#multiple",children:(0,s.jsx)(n.code,{children:"multiple"})})," settings."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['--colors', 'red', 'blue', 'green'];\nconst args = parse<{ colors: string[] }>(argv, {\n  options: {\n    colors: {\n      arity: 3,\n      description: 'Pick 3 favorite colors',\n      multiple: true,\n      type: 'string',\n    },\n  },\n});\n\nargs.options.colors; // ['red', 'blue', 'green']\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Arity will not error when 0 values are passed. To control this logic, use the ",(0,s.jsx)(n.code,{children:"validate"})," setting."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"command--option-categories",children:"Command & option categories"}),"\n",(0,s.jsx)(n.p,{children:"While purely an informational feature, as it doesn't pertain to the parser, both commands and\noptions can be define a category. This category can be used within a consumer to group and organize\nbased on the category name."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const args = parse<{ color: string }>(argv, {\n  options: {\n    color: {\n      category: 'style',\n      description: 'Your favorite color',\n      type: 'string',\n    },\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Command categories only pertain to the ",(0,s.jsx)(n.code,{children:"Command"})," interface type."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"loose-mode",children:"Loose mode"}),"\n",(0,s.jsx)(n.p,{children:"When loose mode is enabled, the following changes to the parser are made:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Unknown options will be typed as strings and set into the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/Arguments#options",children:(0,s.jsx)(n.code,{children:"options"})})," return object. This supersedes the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/Arguments#unknown",children:(0,s.jsx)(n.code,{children:"unknown"})})," setting as it works differently."]}),"\n",(0,s.jsxs)(n.li,{children:["Short options without a configured parent will no longer throw an error, and will be set into the\n",(0,s.jsx)(n.a,{href:"/api/args/interface/Arguments#options",children:(0,s.jsx)(n.code,{children:"options"})})," return object.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When no value is provided, they will be typed as ",(0,s.jsx)(n.code,{children:"boolean"}),", otherwise as ",(0,s.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["When found in a short option group, they will be typed as ",(0,s.jsx)(n.code,{children:"boolean"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const argv = ['-F', 'k=value', '--legit', 'foo', '--unknown', 'bar'];\nconst args = parse<{ legit: string }>(argv, {\n  loose: true,\n  options: {\n    legit: {\n      description: 'A legitimate option',\n      type: 'string',\n    },\n  },\n});\n\nargs.options; // { F: true, k: 'value', legit: 'foo', unknown: 'bar' }\nargs.unknown; // {}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"This mode should only be used for interoperability with other argument parsers."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"type-casting",children:"Type casting"}),"\n",(0,s.jsxs)(n.p,{children:["While option and param values are configured as ",(0,s.jsx)(n.code,{children:"boolean"}),", ",(0,s.jsx)(n.code,{children:"number"}),", or ",(0,s.jsx)(n.code,{children:"string"})," types, arguments\npassed on the command line are always strings. Because of this, the parser will type cast all\ncaptured values before returning the final result, as a means for easier interoperability."]}),"\n",(0,s.jsx)(n.p,{children:"This type casting follows specific semantics (below) and may have side-effects depending on the\ninput provided."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When a ",(0,s.jsx)(n.code,{children:"boolean"}),", the following strings will be cast to ",(0,s.jsx)(n.code,{children:"true"}),": true, on, yes, 1. The inverse will\nbe cast to ",(0,s.jsx)(n.code,{children:"false"}),": false, off, no, 0. Other unsupported strings will also be cast to ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["When a ",(0,s.jsx)(n.code,{children:"number"}),", the string will be cast using ",(0,s.jsx)(n.code,{children:"Number()"}),". If a NaN occurs, the number will return\na ",(0,s.jsx)(n.code,{children:"0"})," (use the ",(0,s.jsx)(n.code,{children:"validate"})," setting for more control)."]}),"\n",(0,s.jsx)(n.li,{children:"Strings are used as-is. Values with spaces or special characters should be wrapped in double\nquotes."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"validation-checks",children:"Validation checks"}),"\n",(0,s.jsx)(n.p,{children:"For improved interoperability and usability, the parser is strict, logging the following parse and\nvalidation errors."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/api/args/class/ParseError",children:(0,s.jsx)(n.code,{children:"ParseError"})}),"s are logged for invalid syntax, unknown options, and\nformatting. The failed argument and its index are stored as ",(0,s.jsx)(n.code,{children:"arg"})," and ",(0,s.jsx)(n.code,{children:"index"})," properties on the\nerror instance, respectively."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/api/args/class/ValidationError",children:(0,s.jsx)(n.code,{children:"ValidationError"})}),"s are logged for invalid values, types,\nsettings, and more. The invalid option (when applicable), is stored as the ",(0,s.jsx)(n.code,{children:"option"})," property."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Furthermore, errors are not thrown and instead are returned as an array in the ",(0,s.jsx)(n.a,{href:"/api/args/function/parse",children:(0,s.jsx)(n.code,{children:"parse()"})}),"\nresult, under the ",(0,s.jsx)(n.a,{href:"/api/args/interface/Arguments#errors",children:(0,s.jsx)(n.code,{children:"errors"})})," property. It's designed this way\nso that command line interfaces and or applications have full control, and can theoretically provide\noutput like the following."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'An error has occurred:\n\n  foo_bar --progressive --interactive -Y\n  \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n     \u2514\u2500 Invalid "foo_bar" command format. Must be letters, numbers, and dashes.\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"formatting-args",children:"Formatting args"}),"\n",(0,s.jsxs)(n.p,{children:["If for some reason you need to format the args result from ",(0,s.jsx)(n.a,{href:"/api/args/function/parse",children:(0,s.jsx)(n.code,{children:"parse()"})})," back into an array of\nstring arguments, the ",(0,s.jsx)(n.a,{href:"/api/args/function/format",children:(0,s.jsx)(n.code,{children:"format()"})})," function can be used. This function will use the values\nas is and does not reference the settings object, so all formatted arguments will be in their long\nform, and will not use inline values."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { format } from '@boost/args';\n\n// cmd --string abc --numbers 123 456 --bool foo bar baz -- qux --version\nconst argv = format({\n  command: ['cmd'],\n  options: { string: 'abc', numbers: [123, 456], bool: true },\n  params: ['foo', 'bar', 'baz'],\n  rest: ['qux', '--version'],\n});\n"})})]})}function g(e={}){const{wrapper:n}={...(0,a.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},2548:(e,n,r)=>{r.d(n,{c:()=>i});r(6952);var s=r(8112);const a={tabItem:"tabItem_wHwb"};var t=r(1948);function i(e){let{children:n,hidden:r,className:i}=e;return(0,t.jsx)("div",{role:"tabpanel",className:(0,s.c)(a.tabItem,i),hidden:r,children:n})}},240:(e,n,r)=>{r.d(n,{c:()=>p});var s=r(6952),a=r(8112),t=r(320),i=r(500),o=r(6576);const l={tabList:"tabList_J5MA",tabItem:"tabItem_l0OV"};var c=r(1948);function d(e){let{className:n,block:r,selectedValue:s,selectValue:i,tabValues:o}=e;const d=[],{blockElementScrollPositionUntilNextRender:h}=(0,t.MV)(),u=e=>{const n=e.currentTarget,r=d.indexOf(n),a=o[r].value;a!==s&&(h(n),i(a))},p=e=>{var n;let r=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var s;const n=d.indexOf(e.currentTarget)+1;r=null!=(s=d[n])?s:d[0];break}case"ArrowLeft":{var a;const n=d.indexOf(e.currentTarget)-1;r=null!=(a=d[n])?a:d[d.length-1];break}}null==(n=r)||n.focus()};return(0,c.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.c)("tabs",{"tabs--block":r},n),children:o.map((e=>{let{value:n,label:r,attributes:t}=e;return(0,c.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>d.push(e),onKeyDown:p,onClick:u,...t,className:(0,a.c)("tabs__item",l.tabItem,null==t?void 0:t.className,{"tabs__item--active":s===n}),children:null!=r?r:n},n)}))})}function h(e){let{lazy:n,children:r,selectedValue:a}=e;const t=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){const e=t.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,c.jsx)("div",{className:"margin-top--md",children:t.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function u(e){const n=(0,i.a)(e);return(0,c.jsxs)("div",{className:(0,a.c)("tabs-container",l.tabList),children:[(0,c.jsx)(d,{...e,...n}),(0,c.jsx)(h,{...e,...n})]})}function p(e){const n=(0,o.c)();return(0,c.jsx)(u,{...e,children:(0,i.A)(e.children)},String(n))}},500:(e,n,r)=>{r.d(n,{A:()=>c,a:()=>p});var s=r(6952),a=r(7976),t=r(2508),i=r(440),o=r(2484),l=r(900);function c(e){var n,r;return null!=(n=null==(r=s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:r.filter(Boolean))?n:[]}function d(e){const{values:n,children:r}=e;return(0,s.useMemo)((()=>{const e=null!=n?n:function(e){return c(e).map((e=>{let{props:{value:n,label:r,attributes:s,default:a}}=e;return{value:n,label:r,attributes:s,default:a}}))}(r);return function(e){const n=(0,o.w)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,r])}function h(e){let{value:n,tabValues:r}=e;return r.some((e=>e.value===n))}function u(e){let{queryString:n=!1,groupId:r}=e;const t=(0,a.Uz)(),o=function(e){let{queryString:n=!1,groupId:r}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=r?r:null}({queryString:n,groupId:r});return[(0,i._M)(o),(0,s.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(t.location.search);n.set(o,e),t.replace({...t.location,search:n.toString()})}),[o,t])]}function p(e){const{defaultValue:n,queryString:r=!1,groupId:a}=e,i=d(e),[o,c]=(0,s.useState)((()=>function(e){var n;let{defaultValue:r,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!h({value:r,tabValues:s}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+r+'" but none of its children has the corresponding value. Available values are: '+s.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return r}const a=null!=(n=s.find((e=>e.default)))?n:s[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[p,g]=u({queryString:r,groupId:a}),[m,f]=function(e){let{groupId:n}=e;const r=function(e){return e?"docusaurus.tab."+e:null}(n),[a,t]=(0,l.IN)(r);return[a,(0,s.useCallback)((e=>{r&&t.set(e)}),[r,t])]}({groupId:a}),x=(()=>{const e=null!=p?p:m;return h({value:e,tabValues:i})?e:null})();(0,t.c)((()=>{x&&c(x)}),[x]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error("Can't select invalid tab value="+e);c(e),g(e),f(e)}),[g,f,i]),tabValues:i}}},5392:(e,n,r)=>{r.d(n,{c:()=>a});var s=r(1948);function a(e){let{children:n,type:r}=e;return(0,s.jsx)("span",{className:"badge badge--"+r,children:n})}},302:(e,n,r)=>{r.d(n,{c:()=>c});var s=r(4308),a=r(3752),t=r(5392);const i={badgeGroup:"badgeGroup_syf7",apiLink:"apiLink_JWAN"};var o=r(1948);function l(e){let{children:n}=e;return(0,o.jsx)("span",{className:i.badgeGroup,children:n})}function c(e){let{api:n,backend:r,frontend:c,tooling:d}=e;return(0,o.jsxs)(o.Fragment,{children:[n&&(0,o.jsxs)(s.default,{className:i.apiLink,to:n,children:["API ",(0,o.jsx)(a.c,{})]}),(0,o.jsxs)(l,{children:[r&&(0,o.jsx)(t.c,{type:"warning",children:"Backend"}),c&&(0,o.jsx)(t.c,{type:"success",children:"Frontend"}),d&&(0,o.jsx)(t.c,{type:"primary",children:"Tooling"})]})]})}},3460:(e,n,r)=>{r.d(n,{I:()=>o,M:()=>i});var s=r(6952);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);